{"version":3,"sources":["main.js","misc.js","histogram.js","clusternetwork.js","scatterplot.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hivtrace.js","sourcesContent":["var root = this;\n\ndatamonkey.hivtrace = function () {};\n\nif (typeof exports !== 'undefined') {\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = datamonkey.hivtrace;\n  }\n\n  exports.datamonkey.hivtrace = datamonkey.hivtrace;\n\n} else {\n\n  root.datamonkey.hivtrace = datamonkey.hivtrace;\n\n}\n","//_ = require('underscore');\n\nfunction hivtrace_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var adjacency_list = {};\n\n    edges.forEach(function(e, i) {\n\n        function in_nodes(n, id) {\n            return n.id == id;\n        }\n\n        var seq_ids = e[\"sequences\"];\n\n        var n1 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[0])\n            })[0],\n            n2 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[1])\n            })[0];\n\n        adjacency_list[n1.id] ? adjacency_list[n1.id].push(n2) : adjacency_list[n1.id] = [n2];\n        adjacency_list[n2.id] ? adjacency_list[n2.id].push(n1) : adjacency_list[n2.id] = [n1];\n\n    });\n\n\n    return adjacency_list;\n\n}\n\nhivtrace_generate_svg_polygon_lookup = {\n};\n\n_.each (_.range (3,20), function (d) {\n    var angle_step    = Math.PI*2/d;\n    hivtrace_generate_svg_polygon_lookup [d] = _.map (_.range (1,d), function (i) {\n        return [Math.cos (angle_step * i), Math.sin (angle_step * i)];\n    });\n});\n\nfunction hivtrace_generate_svg_symbol (type) {\n    switch (type) {\n        case 'circle':\n        case 'cross':\n        case 'diamond':\n        case 'square':\n        case 'triangle-down':\n        case 'triangle-up':\n            return  d3.svg.symbol().type (type);\n\n        case 'pentagon':\n            return hivtrace_generate_svg_polygon().sides (5);\n        case 'hexagon':\n            return hivtrace_generate_svg_polygon().sides (6);\n        case 'septagon':\n            return hivtrace_generate_svg_polygon().sides (7);\n        case 'octagon':\n            return hivtrace_generate_svg_polygon().sides (8);\n    }\n    return node;\n}\n\nfunction hivtrace_generate_svg_polygon () {\n    var self = this;\n\n\n    function polygon () {\n        var path  = \" M\" + self.radius + \" 0\";\n\n        if (self.sides in hivtrace_generate_svg_polygon_lookup) {\n             path += hivtrace_generate_svg_polygon_lookup[self.sides].map (function (value) {\n                return \" L\" + self.radius * value[0] + \" \" + self.radius * value[1];\n             }).join (\" \");\n        } else {\n            var angle_step    = Math.PI*2/self.sides,\n                current_angle = 0;\n            for (i = 0; i < self.sides - 1; i++) {\n                current_angle += angle_step;\n                path += \" L\" + self.radius * Math.cos (current_angle) + \" \" + self.radius * Math.sin (current_angle);\n            }\n        }\n\n        path += \" Z\";\n        return path;\n    }\n\n    polygon.sides = function (attr) {\n        if (_.isNumber (attr) && attr > 2) {\n            self.sides = attr;\n            return polygon;\n        }\n        return self.sides;\n    }\n\n    polygon.type = function () {\n       return polygon;\n    }\n\n    polygon.size = function(attr) {\n        if (_.isNumber (attr)) {\n            self.size = attr;\n            self.radius = Math.sqrt (attr/Math.PI);\n            return polygon;\n        }\n        return self.size;\n    }\n\n    polygon.size (64);\n    self.sides  = 6;\n\n    return polygon;\n}\n\nfunction hivtrace_new_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    nodes.forEach (function (n) {\n        n.neighbors = d3.set();\n    });\n\n    edges.forEach (function (e) {\n        nodes[e.source].neighbors.add(e.target);\n        nodes[e.target].neighbors.add(e.source);\n    });\n\n}\n\n// Reconstructs path from floyd-warshall algorithm\nfunction hivtrace_get_path(next, i, j) {\n\n    var all_paths = [];\n    var i = parseInt(i);\n    var j = parseInt(j);\n\n    for (var c = 0; c < next[i][j].length; c++) {\n\n        var k = next[i][j][c];\n        var intermediate = k;\n\n        if (intermediate == null || intermediate == i) {\n            return [\n                [parseInt(i), parseInt(j)]\n            ];\n        } else {\n\n            var paths_i_k = hivtrace_get_path(next, i, intermediate);\n            var paths_k_j = hivtrace_get_path(next, intermediate, j);\n\n            for (var i_k_index = 0; i_k_index < paths_i_k.length; i_k_index++) {\n                var i_k = paths_i_k[i_k_index];\n                for (var k_j_index = 0; k_j_index < paths_k_j.length; k_j_index++) {\n                    var k_j = paths_k_j[k_j_index];\n                    if (i_k.length) {\n                        if ((i_k[0] == i) && (i_k[i_k.length - 1] == k) && (k_j[0] == k) && (k_j[k_j.length - 1] == j)) {\n                            i_k.pop()\n                            all_paths.push(i_k.concat(k_j));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return all_paths;\n\n}\n\nfunction hivtrace_paths_with_node(node, next, i, j) {\n\n    var paths = hivtrace_get_path(next, i, j);\n\n    // Retrieve intermediary paths\n    paths = paths.map(function(sublist) {\n        return sublist.slice(1, -1)\n    });\n\n    if (!paths) {\n        return 0;\n    }\n\n    var num_nodes = [];\n\n    for (var i = 0; i < paths.length; i++) {\n        sublist = paths[i];\n        num_nodes.push(d3.sum(sublist.map(function(n) {\n            return n == node;\n        })));\n    }\n\n    var mean = d3.mean(num_nodes);\n\n    if (mean == undefined) {\n        mean = 0;\n    }\n\n    return mean;\n\n}\n\n\n// Same as compute shortest paths, but with an additional next parameter for reconstruction\nfunction hivtrace_compute_shortest_paths_with_reconstruction(obj, subset, use_actual_distances) {\n\n    // Floyd-Warshall implementation\n    var distances = [];\n    var next = [];\n    var nodes = obj.Nodes;\n    var edges = obj.Edges;\n    var node_ids = [];\n\n    var adjacency_list = datamonkey.hivtrace.cluster_adjacency_list(obj);\n\n    if (!subset) {\n        subset = Object.keys(adjacency_list);\n    }\n\n    var node_count = subset.length;\n\n    for (var i = 0; i < subset.length; i++) {\n        var a_node = subset[i];\n        var empty_arr = _.range(node_count).map(function(d) {\n            return null\n        });\n        var zeroes = _.range(node_count).map(function(d) {\n            return null\n        });\n        distances.push(zeroes);\n        next.push(empty_arr);\n    };\n\n    for (var index = 0; index < subset.length; index++) {\n        var a_node = subset[index];\n        for (var index2 = 0; index2 < subset.length; index2++) {\n            var second_node = subset[index2];\n            if (second_node != a_node) {\n                if (adjacency_list[a_node].map(function(n) {\n                        return n.id\n                    }).indexOf(second_node) != -1) {\n                    distances[index][index2] = 1;\n                    distances[index2][index] = 1;\n                }\n            }\n        }\n    }\n\n    for (var index_i = 0; index_i < subset.length; index_i++) {\n        var n_i = subset[index_i];\n        for (var index_j = 0; index_j < subset.length; index_j++) {\n            var n_j = subset[index_j];\n            if (index_i == index_j) {\n                next[index_i][index_j] = [];\n            } else {\n                next[index_i][index_j] = [index_i];\n            }\n        }\n    }\n\n    // clone distances\n    var distances2 = _.map(distances, _.clone);\n    var c = 0;\n\n    for (var index_k = 0; index_k < subset.length; index_k++) {\n        var n_k = subset[index_k];\n        for (var index_i = 0; index_i < subset.length; index_i++) {\n            var n_i = subset[index_i];\n            for (var index_j = 0; index_j < subset.length; index_j++) {\n                var n_j = subset[index_j];\n\n                if (n_i != n_j) {\n\n                    d_ik = distances[index_k][index_i];\n                    d_jk = distances[index_k][index_j];\n                    d_ij = distances[index_i][index_j];\n\n                    if (d_ik != null && d_jk != null) {\n                        d_ik += d_jk;\n                        if (d_ij == null || (d_ij > d_ik)) {\n                            distances2[index_i][index_j] = d_ik;\n                            distances2[index_j][index_i] = d_ik;\n                            next[index_i][index_j] = [];\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                            continue;\n                        } else if (d_ij == d_ik) {\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                        }\n                    }\n                    c++;\n                    distances2[index_j][index_i] = distances[index_j][index_i];\n                    distances2[index_i][index_j] = distances[index_i][index_j];\n                }\n            }\n        }\n\n        var t = distances2;\n        distances2 = distances;\n        distances = t;\n\n    }\n\n    return {\n        'ordering': subset,\n        'distances': distances,\n        'next': next\n    };\n\n}\n\nfunction hivtrace_filter_to_node_in_cluster(node, obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges,\n        cluster_id = null;\n\n    // Retrieve nodes that are part of the cluster\n    var node_obj = nodes.filter(function(n) {\n        return node == n.id;\n    });\n\n    if (node_obj) {\n        cluster_id = node_obj[0].cluster;\n    } else {\n        console.log('could not find node');\n        return null;\n    }\n\n    // Filter out all edges and nodes that belong to the cluster\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster_id == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n    return filtered_obj;\n\n}\n\nfunction hivtrace_compute_betweenness_centrality_all_nodes_in_cluster(cluster, obj, cb) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n\n    // get length of cluster\n    if (nodes_in_cluster.length > 70) {\n        cb('cluster too large', null);\n        return;\n    }\n\n    // get paths\n    var paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n\n    var betweenness = {}\n    nodes_in_cluster.forEach(function(n) {\n        betweenness[n.id] = hivtrace_compute_betweenness_centrality(n.id, filtered_obj, paths);\n    });\n\n    cb(null, betweenness);\n    return;\n\n}\n\n// Returns dictionary of nodes' betweenness centrality\n// Utilizes the Floyd-Warshall Algorithm with reconstruction\nfunction hivtrace_compute_betweenness_centrality(node, obj, paths) {\n\n    if (!paths) {\n        var filtered_obj = hivtrace_filter_to_node_in_cluster(node, obj)\n        paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    }\n\n    // find index of id\n    var index = paths['ordering'].indexOf(node);\n\n    if (index == -1) {\n        return null;\n    }\n\n    var length = paths['distances'].length;\n\n    if (length != 2) {\n        scale = 1 / ((length - 1) * (length - 2));\n    } else {\n        scale = 1;\n    }\n\n\n    // If s->t goes through 1, add to sum\n    // Reconstruct each shortest path and check if node is in it\n    var paths_with_node = [];\n    for (i in _.range(length)) {\n        for (j in _.range(length)) {\n            paths_with_node.push(hivtrace_paths_with_node(index, paths['next'], i, j));\n        }\n    }\n\n    return d3.sum(paths_with_node) * scale;\n\n}\n\n\nfunction hivtrace_compute_node_degrees(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n    for (var n in nodes) {\n        nodes[n].degree = 0;\n    }\n\n    for (var e in edges) {\n        nodes[edges[e].source].degree++;\n        nodes[edges[e].target].degree++;\n    }\n\n}\n\nfunction hivtrace_get_node_by_id(id, obj) {\n    return obj.Nodes.filter(function(n) {\n        return id == n.id\n    })[0] || undefined;\n}\n\nfunction hivtrace_compute_cluster_betweenness(obj, callback) {\n\n    var nodes = obj.Nodes;\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    // Get all unique clusters\n    var clusters = nodes.map(function(n) {\n        return n.cluster\n    });\n    var unique_clusters = clusters.filter(onlyUnique);\n\n    var cb_count = 0;\n\n    function cb(err, results) {\n\n        cb_count++;\n\n        for (node in results) {\n            hivtrace_get_node_by_id(node, obj)['betweenness'] = results[node];\n        }\n\n        if (cb_count >= unique_clusters.length) {\n            callback('done');\n        }\n\n    }\n\n    // Compute betweenness in parallel\n    unique_clusters.forEach(function(cluster_id) {\n        datamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster(cluster_id, obj, cb);\n    });\n\n    // once all settled callback\n\n}\n\n\nfunction hivtrace_is_contaminant(node) {\n    return node.attributes.indexOf('problematic') != -1;\n}\n\nfunction hivtrace_convert_to_csv(obj, callback) {\n    //Translate nodes to rows, and then use d3.format\n    hivtrace_compute_node_degrees(obj);\n\n    hivtrace_compute_cluster_betweenness(obj, function(err) {\n        var node_array = obj.Nodes.map(function(d) {\n            return [d.id, d.cluster, d.degree, d.betweenness, hivtrace_is_contaminant(d), d.attributes.join(';')]\n        });\n        node_array.unshift(['seqid', 'cluster', 'degree', 'betweenness', 'is_contaminant', 'attributes'])\n        node_csv = d3.csv.format(node_array);\n        callback(null, node_csv);\n    });\n}\n\nfunction hivtrace_export_csv_button(graph, tag) {\n\n    var data = hivtrace_convert_to_csv(graph, function(err, data) {\n        if (data != null) {\n            var pom = document.createElement('a');\n            pom.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(data));\n            pom.setAttribute('download', 'export.csv');\n            pom.className = 'btn btn-default btn-sm';\n            pom.innerHTML = '<span class=\"glyphicon glyphicon-floppy-save\"></span> Export Results';\n            $(tag).append(pom);\n        }\n    });\n\n}\n\nfunction hiv_trace_export_table_to_text(parent_id, table_id, sep) {\n\n    var the_button = d3.select(parent_id).append(\"a\")\n        .attr(\"target\", \"_blank\")\n        .on(\"click\", function(data, element) {\n            var table_tag = d3.select(this).attr(\"data-table\");\n            var table_text = datamonkey.helpers.table_to_text(table_tag);\n            datamonkey.helpers.export_handler(table_text, table_tag.substring(1) + \".tsv\", \"text/tab-separated-values\");\n        })\n        .attr(\"data-table\", table_id);\n\n    the_button.append(\"i\").classed(\"fa fa-download fa-2x\", true);\n    return the_button;\n\n}\n\nhivtrace_compute_local_clustering_coefficients = _.once (function (obj) {\n\n  datamonkey.hivtrace.new_cluster_adjacency_list(obj);\n\n  var nodes = obj.Nodes;\n\n  nodes.forEach (function (n) {\n\n    var a_node = n;\n    var neighborhood_size = a_node.neighbors.size();\n\n    if (neighborhood_size < 2) {\n        a_node.lcc = undefined;\n    } else {\n\n        if (neighborhood_size > 500) {\n            a_node.lcc = datamonkey.hivtrace.too_large;\n        } else {\n            // count triangles\n            neighborhood = a_node.neighbors.values();\n            counter = 0;\n            for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n                for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                    if (nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\n                        counter ++;\n                    }\n                }\n            }\n            a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n        }\n    }\n\n  });\n\n});\n\nfunction hivtrace_render_settings(settings, explanations) {\n    // TODO:\n    //d3.json (explanations, function (error, expl) {\n    //    //console.log (settings);\n    //});\n}\n\nfunction hivtrace_format_value(value, formatter) {\n\n    if (typeof value === 'undefined') {\n        return \"Not computed\";\n    }\n    if (value === datamonkey.hivtrace.undefined) {\n        return \"Undefined\";\n    }\n    if (value === datamonkey.hivtrace.too_large) {\n        return \"Size limit\";\n    }\n\n    if (value === datamonkey.hivtrace.processing) {\n        return '<span class=\"fa fa-spin fa-spinner\"></span>';\n    }\n\n    return formatter ? formatter(value) : value;\n\n}\n\n\nif (typeof datamonkey == 'undefined') {\n    datamonkey = function() {};\n}\n\nif (typeof datamonkey.hivtrace == 'undefined') {\n    datamonkey.hivtrace = function() {};\n}\n\ndatamonkey.hivtrace.compute_node_degrees = hivtrace_compute_node_degrees;\ndatamonkey.hivtrace.export_csv_button = hivtrace_export_csv_button;\ndatamonkey.hivtrace.convert_to_csv = hivtrace_convert_to_csv;\ndatamonkey.hivtrace.betweenness_centrality = hivtrace_compute_betweenness_centrality;\ndatamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster = hivtrace_compute_betweenness_centrality_all_nodes_in_cluster;\ndatamonkey.hivtrace.cluster_adjacency_list = hivtrace_cluster_adjacency_list;\ndatamonkey.hivtrace.new_cluster_adjacency_list = hivtrace_new_cluster_adjacency_list;\ndatamonkey.hivtrace.analysis_settings = hivtrace_render_settings;\ndatamonkey.hivtrace.export_table_to_text = hiv_trace_export_table_to_text;\ndatamonkey.hivtrace.compute_local_clustering = hivtrace_compute_local_clustering_coefficients;\ndatamonkey.hivtrace.undefined = new Object();\ndatamonkey.hivtrace.too_large = new Object();\ndatamonkey.hivtrace.processing = new Object();\ndatamonkey.hivtrace.format_value = hivtrace_format_value;\ndatamonkey.hivtrace.polygon    = hivtrace_generate_svg_polygon;\ndatamonkey.hivtrace.symbol    = hivtrace_generate_svg_symbol;\n","function hivtrace_histogram(graph, histogram_tag, histogram_label) {  \n\n  var defaultFloatFormat = d3.format(\",.2f\");\n  var histogram_w = 300,\n  histogram_h = 300;\n\n  hivtrace_render_histogram(graph[\"Degrees\"][\"Distribution\"], \n                            graph[\"Degrees\"][\"fitted\"], \n                            histogram_w, \n                            histogram_h, \n                            histogram_tag);\n  var label = \"Network degree distribution is best described by the <strong>\" + graph[\"Degrees\"][\"Model\"] + \"</strong> model, with &rho; of \" + \n             defaultFloatFormat(graph[\"Degrees\"][\"rho\"]);\n             \n  if (graph[\"Degrees\"][\"rho CI\"] != undefined) {\n        label += \" (95% CI \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][0]) + \" - \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][1]) + \")\";\n  }\n\n  d3.select (histogram_label).html(label);\n}\n\nfunction hivtrace_render_histogram(counts, fit, w, h, id) {\n\n    var margin = {top: 10, right: 30, bottom: 50, left: 30},\n                width = w - margin.left - margin.right,\n                height = h - margin.top - margin.bottom;\n    \n    var x = d3.scale.linear()\n            .domain([0, counts.length+1])\n            .range([0, width]);\n            \n    var y = d3.scale.log()\n            .domain ([1, d3.max (counts)])\n            .range  ([height,0]);\n            \n    var total = d3.sum(counts);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\");\n        \n    var histogram_svg = d3.select(id).selectAll(\"svg\");\n\n    if (histogram_svg != undefined) {\n        histogram_svg.remove();\n    }\n    \n    var data_to_plot = counts.map (function (d, i) {return {'x' : i+1, 'y' : d+1};});\n    data_to_plot.push ({'x' : counts.length+1, 'y' : 1});\n    data_to_plot.push ({'x' : 0, 'y' : 1});\n    data_to_plot.push ({'x' : 0, 'y' : counts[0]+1});\n   \n    histogram_svg = d3.select(id).insert(\"svg\",\".histogram-label\")\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n    .datum (data_to_plot);\n        \n    var histogram_line = d3.svg.line()\n                        .x(function(d) { return x(d.x); })\n                        .y(function(d) { return y(d.y); })\n                        .interpolate(\"step-before\");\n                        \n    histogram_svg.selectAll (\"path\").remove();\n    histogram_svg.append (\"path\")\n                 .attr (\"d\", function(d) { return histogram_line(d) + \"Z\"; })\n                 .attr (\"class\", \"histogram\");\n    \n    /*var bar = histogram_svg.selectAll(\".bar\")\n    .data(counts.map (function (d) { return d+1; }))\n    .enter().append(\"g\")\n    .attr(\"class\", \"bar\")\n    .attr(\"transform\", function(d,i) { return \"translate(\" + x(i+1) + \",\" + y(d) + \")\"; });\n      \n    bar.append(\"rect\")\n        .attr(\"x\", 1)\n        .attr(\"width\", function (d,i) {return x(i+2) - x(i+1);})\n        .attr(\"height\", function(d) { return height - y(d); })\n        .append (\"title\").text (function (d,i) { return \"\" + counts[i] + \" nodes with degree \" + (i+1);});*/\n        \n      \n\n      if (fit != undefined) {    \n          var fit_line = d3.svg.line()\n              .interpolate(\"linear\")\n              .x(function(d,i) { return x(i+1) + (x(i+1)-x(i))/2; })\n              .y(function(d) { return y(1+d*total); });\n          histogram_svg.append(\"path\").datum(fit)\n            .attr(\"class\", \"line\")\n            .attr(\"d\", function(d) { return fit_line(d); });\n      }\n    \n    var x_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(xAxis);    \n        \n    x_axis.selectAll (\"text\").attr (\"transform\", \"rotate(45)\").attr(\"dx\",\"1em\").attr(\"dy\",\"0.5em\");\n}\n\ndatamonkey.hivtrace.histogram = hivtrace_histogram;\n","var _networkGraphAttrbuteID = \"patient_attribute_schema\";\nvar _networkNodeAttributeID = \"patient_attributes\";\nvar _networkMissing         = 'missing';\nvar _networkMissingOpacity  = '0.1';\nvar _networkMissingColor    = '#999';\nvar _networkContinuousColorStops = 9;\nvar _networkShapeOrdering   = ['circle','square','hexagon','diamond','cross','octagon'];\nvar _defaultFloatFormat = d3.format(\",.2r\");\n\nvar _networkPresetColorSchemes = {'trans_categ' : {\n                                    'Other-Male': '#999999',\n                                    'Heterosexual Contact-Male': '#e31a1c',\n                                    'Other-Child': '#ff7f00',\n                                    'Perinatal': '#ff7f00',\n                                    'MSM': '#1f78b4',\n                                    'IDU-Male': '#33a02c',\n                                    'Other-Female': '#999999',\n                                    'IDU-Female': '#33a02c',\n                                    'MSM & IDU': '#33a02c',\n                                    'Missing': '#999999',\n                                    'Heterosexual Contact-Female': '#e31a1c'\n                                 }};\n\n\nvar hivtrace_cluster_network_graph = function (json, network_container, network_status_string, network_warning_tag, button_bar_ui, attributes, filter_edges_toggle, clusters_table, nodes_table, parent_container, options) {\n\n  // [REQ] json                        :          the JSON object containing network nodes, edges, and meta-information\n  // [REQ] network_container           :          the CSS selector of the DOM element where the SVG containing the network will be placed (e.g. '#element')\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] network_warning_tag         :          the CSS selector of the DOM element where the any warning messages would go (e.g. '#element')\n  // [OPT] button_bar_ui               :          the ID of the control bar which can contain the following elements (prefix = button_bar_ui value)\n  //                                                - [prefix]_cluster_operations_container : a drop-down for operations on clusters\n  //                                                - [prefix]_attributes :  a drop-down for operations on attributes\n  //                                                - [prefix]_filter : a text box used to search the graph\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] attributes                  :          A JSON object with mapped node attributes\n\n  var self = new Object;\n\n    self.ww = options && options[\"width\"] ? options[\"width\"] : d3.select(parent_container).property(\"clientWidth\");\n    self.nodes = [];\n    self.edges = [];\n    self.clusters = [];\n    self.cluster_sizes = [];\n    self.colorizer = {'selected': function (d) {return d == 'selected' ? d3.rgb(51, 122, 183) : '#FFF'}};\n    self.node_shaper = {'id' : null, 'shaper' : function () { return 'circle' }};\n    self.filter_edges = true,\n    self.hide_hxb2 = false,\n    self.charge_correction = 5,\n    self.margin = {top: 20, right: 10, bottom: 30, left: 10},\n    self.width  = self.ww - self.margin.left - self.margin.right,\n    self.height = self.width * 9 / 16,\n    self.cluster_table = d3.select (clusters_table),\n    self.node_table = d3.select (nodes_table),\n    self.needs_an_update = false,\n    self.json = json,\n    self.gradient_id = 0;\n\n\n\n  var cluster_mapping = {},\n      l_scale = 5000,   // link scale\n      graph_data = self.json,     // the raw JSON network object\n      max_points_to_render = 500,\n      warning_string     = \"\",\n      singletons         = 0,\n      open_cluster_queue = [],\n      currently_displayed_objects,\n      gravity_scale = d3.scale.pow().exponent (0.5).domain ([1,100000]).range ([0.1,0.15]);\n\n  /*------------ D3 globals and SVG elements ---------------*/\n\n  var network_layout = d3.layout.force()\n    .on(\"tick\", tick)\n    .charge(function(d) { if (d.cluster_id) return self.charge_correction*(-20-5*Math.pow(d.children.length,0.7)); return self.charge_correction*(-5-20*Math.sqrt(d.degree)); })\n    .linkDistance(function(d) { return Math.max(d.length,0.005)*l_scale; })\n    .linkStrength (function (d) { if (d.support != undefined) { return 2*(0.5-d.support);} return 1;})\n    .chargeDistance (l_scale*0.25)\n    .gravity (gravity_scale(json.Nodes.length))\n    .friction (0.25);\n\n  d3.select(network_container).selectAll (\".my_progress\").remove();\n\n\n  d3.select(network_container).selectAll (\"svg\").remove();\n  self.node_table.selectAll (\"*\").remove();\n  self.cluster_table.selectAll (\"*\").remove();\n\n  var network_svg = d3.select(network_container).append(\"svg:svg\")\n      //.style (\"border\", \"solid black 1px\")\n      .attr(\"id\", \"network-svg\")\n      .attr(\"width\", self.width + self.margin.left + self.margin.right)\n      .attr(\"height\", self.height + self.margin.top + self.margin.bottom);\n\n      //.append(\"g\")\n      // .attr(\"transform\", \"translate(\" + self.margin.left + \",\" + self.margin.top + \")\");\n\n  var legend_svg = network_svg.append (\"g\").attr(\"transform\", \"translate(5,5)\");\n\n  network_svg.append(\"defs\").append(\"marker\")\n      .attr(\"id\", \"arrowhead\")\n      .attr(\"refX\", 9) /*must be smarter way to calculate shift*/\n      .attr(\"refY\", 2)\n      .attr(\"markerWidth\",  6)\n      .attr(\"markerHeight\", 4)\n      .attr(\"orient\", \"auto\")\n      .attr(\"stroke\", \"#666666\")\n      .attr(\"fill\", \"#AAAAAA\")\n      .append(\"path\")\n          .attr(\"d\", \"M 0,0 V 4 L6,2 Z\"); //this is actual shape for arrowhead\n\n\n  /*var gradient = network_svg.append(\"defs\").append (\"radialGradient\")\n    .attr (\"id\", \"hiv-trace-gradient-test\");\n\n  gradient.append (\"stop\").attr (\"offset\", \"10%\").attr (\"stop-color\", \"blue\");\n  gradient.append (\"stop\").attr (\"offset\", \"90%\").attr (\"stop-color\", \"red\");*/\n\n  change_window_size();\n\n\n  /*------------ Network layout code ---------------*/\n  var handle_cluster_click = function (cluster, release) {\n\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select (\"#\" + id);\n\n    if (menu_object.empty()) {\n      menu_object = container.append (\"ul\")\n        .attr (\"id\", id)\n        .attr (\"class\",\"dropdown-menu\")\n        .attr (\"role\", \"menu\");\n    }\n\n    menu_object.selectAll (\"li\").remove();\n\n    var already_fixed = cluster && cluster.fixed == 1;\n\n\n    if (cluster) {\n      menu_object.append(\"li\").append (\"a\")\n                   .attr(\"tabindex\", \"-1\")\n                   .text(\"Expand cluster\")\n                   .on (\"click\", function (d) {\n                      cluster.fixed = 0;\n                      expand_cluster_handler(cluster, true);\n                      menu_object.style (\"display\", \"none\");\n                      });\n\n      menu_object.append(\"li\").append (\"a\")\n                   .attr (\"tabindex\", \"-1\")\n                   .text (\"Center on screen\")\n                   .on (\"click\", function (d) {\n                      cluster.fixed = 0;\n                      center_cluster_handler(cluster);\n                      menu_object.style (\"display\", \"none\");\n                      });\n\n     menu_object.append(\"li\").append (\"a\")\n               .attr (\"tabindex\", \"-1\")\n               .text (function (d) {if (cluster.fixed) return \"Release fix\"; return \"Fix in place\";})\n               .on (\"click\", function (d) {\n                  cluster.fixed = !cluster.fixed;\n                  menu_object.style (\"display\", \"none\");\n                  });\n\n     cluster.fixed = 1;\n\n     menu_object.style (\"position\", \"absolute\")\n        .style(\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style(\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style(\"display\", \"block\");\n\n    } else {\n      if (release) {\n        release.fixed = 0;\n      }\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function (d) {handle_cluster_click(null, already_fixed ? null : cluster);}, true);\n\n  };\n\n  var handle_node_click = function (node) {\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select (\"#\" + id);\n\n    if (menu_object.empty()) {\n      menu_object = container.append (\"ul\")\n        .attr (\"id\", id)\n        .attr (\"class\",\"dropdown-menu\")\n        .attr (\"role\", \"menu\");\n    }\n\n    menu_object.selectAll (\"li\").remove();\n\n    if (node) {\n      node.fixed = 1;\n      menu_object.append(\"li\").append (\"a\")\n                   .attr(\"tabindex\", \"-1\")\n                   .text(\"Collapse cluster\")\n                   .on (\"click\", function (d) {\n                      node.fixed = 0;\n                      collapse_cluster_handler(node, true)\n                      menu_object.style (\"display\", \"none\");\n                      });\n\n      menu_object.style (\"position\", \"absolute\")\n        .style (\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style (\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style (\"display\", \"block\");\n\n    } else {\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function (d) {handle_node_click(null);}, true);\n\n  };\n\n  function get_initial_xy (nodes, cluster_count, exclude ) {\n      var d_clusters = {'id': 'root', 'children': []};\n      for (var k = 0; k < cluster_count; k+=1) {\n       if (exclude != undefined && exclude[k+1] != undefined) {continue;}\n          d_clusters.children.push ({'cluster_id' : k+1, 'children': nodes.filter (function (v) {return v.cluster == k+1;})});\n      }\n\n      var treemap = d3.layout.pack()\n      .size([self.width, self.height])\n      //.sticky(true)\n      .children (function (d)  {return d.children;})\n      .value(function(d) { return 1;});\n\n      return treemap.nodes (d_clusters);\n  }\n\n  function prepare_data_to_graph () {\n\n      var graphMe = {};\n      graphMe.all = [];\n      graphMe.edges = [];\n      graphMe.nodes = [];\n      graphMe.clusters = [];\n\n      expandedClusters = [];\n      drawnNodes = [];\n\n\n      self.clusters.forEach (function (x) {\n          // Check if hxb2_linked is in a child\n          var hxb2_exists = x.children.some(function(c) {return c.hxb2_linked}) && self.hide_hxb2;\n          if(!hxb2_exists) {\n            if (x.collapsed) {\n                graphMe.clusters.push (x);\n                graphMe.all.push(x);\n            } else {\n                expandedClusters[x.cluster_id] = true;\n            }\n          }\n      });\n\n      self.nodes.forEach (function (x, i) {\n          if (expandedClusters[x.cluster]) {\n              drawnNodes[i] = graphMe.nodes.length +  graphMe.clusters.length;\n              graphMe.nodes.push(x);\n              graphMe.all.push(x);\n          }\n\n      });\n\n      self.edges.forEach (function (x) {\n\n          if(!(x.removed && self.filter_edges)) {\n            if (drawnNodes[x.source] != undefined && drawnNodes[x.target] != undefined) {\n\n                var y = {};\n                for (var prop in x) {\n                    y[prop] = x[prop];\n                }\n\n                y.source = drawnNodes[x.source];\n                y.target = drawnNodes[x.target];\n                graphMe.edges.push(y);\n            }\n          }\n      });\n\n      return graphMe;\n\n  }\n\n  function default_layout (clusters, nodes, exclude_cluster_ids) {\n        init_layout = get_initial_xy (nodes, self.cluster_sizes.length, exclude_cluster_ids);\n        clusters = init_layout.filter (function (v,i,obj) { return  !(typeof v.cluster_id === \"undefined\");});\n\n        var sizes = network_layout.size();\n\n        _.each (nodes,  function (n) {n.x += n.dx/2; n.y += n.dy/2});\n        clusters.forEach (collapse_cluster);\n        return [clusters, nodes];\n    }\n\n function change_spacing (delta) {\n    self.charge_correction = self.charge_correction * delta;\n    network_layout.start ();\n }\n\n function change_window_size (delta, trigger) {\n\n    if (delta) {\n\n        self.width  += delta;\n        self.height += delta;\n\n        var rescale_x = d3.scale.linear().domain (d3.extent (network_layout.nodes(), function (node) {return node.x})).range ([50,self.width-50]),\n            rescale_y = d3.scale.linear().domain (d3.extent (network_layout.nodes(), function (node) {return node.y})).range ([50,self.height-50]);\n\n        _.each (network_layout.nodes(), function (node) {\n            node.x = rescale_x(node.x);\n            node.y = rescale_y(node.y);\n        });\n\n    }\n\n    self.width  = Math.min (Math.max (self.width, 200), 4000);\n    self.height = Math.min (Math.max (self.height, 200), 4000);\n\n    network_layout.size ([self.width, self.height]);\n    network_svg.attr (\"width\", self.width).attr (\"height\", self.height);\n\n    if (trigger) {\n        network_layout.start ();\n    }\n }\n\n self.compute_adjacency_list = _.once(function () {\n\n    self.nodes.forEach (function (n) {\n        n.neighbors = d3.set();\n    });\n\n    self.edges.forEach (function (e) {\n        self.nodes[e.source].neighbors.add(e.target);\n        self.nodes[e.target].neighbors.add(e.source);\n    });\n\n });\n\n self.compute_local_clustering_coefficients = _.once (function () {\n\n    self.compute_adjacency_list();\n\n    self.nodes.forEach (function (n) {\n        _.defer (function (a_node) {\n            neighborhood_size = a_node.neighbors.size ();\n            if (neighborhood_size < 2) {\n                a_node.lcc = datamonkey.hivtrace.undefined;\n            } else {\n                if (neighborhood_size > 500) {\n                    a_node.lcc = datamonkey.hivtrace.too_large;\n                } else {\n                    // count triangles\n                    neighborhood = a_node.neighbors.values();\n                    counter = 0;\n                    for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n                        for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                            if (self.nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\n                                counter ++;\n                            }\n                        }\n                    }\n\n                    a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n                }\n            }\n\n        }, n);\n    });\n\n });\n\n  self.get_node_by_id = function(id) {\n    return self.nodes.filter(function(n) {\n        return n.id == id;\n    })[0];\n\n\n  }\n\n self.compute_local_clustering_coefficients_worker = _.once (function () {\n\n    var worker = new Worker('workers/lcc.js');\n\n    worker.onmessage = function(event) {\n\n      var nodes = event.data.Nodes;\n\n      nodes.forEach(function(n) {\n        node_to_update = self.get_node_by_id(n.id);\n        node_to_update.lcc = n.lcc ? n.lcc : datamonkey.hivtrace.undefined;\n      });\n\n    };\n\n    var worker_obj = {}\n    worker_obj[\"Nodes\"] = self.nodes;\n    worker_obj[\"Edges\"] = self.edges;\n    worker.postMessage(worker_obj);\n\n });\n\n\n\n  estimate_cubic_compute_cost = _.memoize(function (c) {\n    self.compute_adjacency_list();\n    return _.reduce (_.first(_.pluck (c.children, \"degree\").sort (d3.descending),3),function (memo, value) {return memo*value;},1);\n  }, function (c) {return c.cluster_id;});\n\n  self.compute_global_clustering_coefficients = _.once (function () {\n    self.compute_adjacency_list();\n\n    self.clusters.forEach (function (c) {\n         _.defer (function (a_cluster) {\n                cluster_size = a_cluster.children.length;\n                if (cluster_size < 3) {\n                    a_cluster.cc = datamonkey.hivtrace.undefined;\n                } else {\n                    if (estimate_cubic_compute_cost (a_cluster, true) >= 5000000) {\n                        a_cluster.cc = datamonkey.hivtrace.too_large;\n                    } else {\n                        // pull out all the nodes that have this cluster id\n                        member_nodes = [];\n\n                        var triads = 0;\n                        var triangles = 0;\n\n                        self.nodes.forEach (function (n,i) {if (n.cluster == a_cluster.cluster_id) {member_nodes.push (i);}});\n                        member_nodes.forEach (function (node) {\n                            my_neighbors = self.nodes[node].neighbors.values().map (function (d) {return +d;}).sort (d3.ascending);\n                            for (n1 = 0; n1 < my_neighbors.length; n1 += 1) {\n                                for (n2 = n1 + 1; n2 < my_neighbors.length; n2 += 1) {\n                                    triads += 1;\n                                    if (self.nodes[my_neighbors[n1]].neighbors.has (my_neighbors[n2])) {\n                                        triangles += 1;\n                                    }\n                                }\n                            }\n                        });\n\n                        a_cluster.cc = triangles/triads;\n                    }\n                }\n\n            }, c);\n        });\n });\n\n self.mark_nodes_as_processing = function (property) {\n    self.nodes.forEach (function (n) { n[property] = datamonkey.hivtrace.processing });\n  }\n\n self.compute_graph_stats = function () {\n\n    d3.select (this).classed (\"disabled\", true).select(\"i\").classed ({\"fa-calculator\": false, \"fa-cog\": true, \"fa-spin\": true});\n    self.mark_nodes_as_processing('lcc');\n    self.compute_local_clustering_coefficients_worker();\n    self.compute_global_clustering_coefficients();\n    d3.select (this).remove();\n\n };\n\n\n  /*------------ Constructor ---------------*/\n  function initial_json_load() {\n    var connected_links = [];\n    var total = 0;\n    var exclude_cluster_ids = {};\n    self.has_hxb2_links = false;\n    self.cluster_sizes = [];\n\n    graph_data.Nodes.forEach (function (d) {\n          if (typeof self.cluster_sizes[d.cluster-1]  === \"undefined\") {\n            self.cluster_sizes[d.cluster-1] = 1;\n          } else {\n            self.cluster_sizes[d.cluster-1] ++;\n          }\n          if (\"is_lanl\" in d) {\n            d.is_lanl = d.is_lanl == \"true\";\n          }\n\n\n          if (d.attributes.indexOf (\"problematic\") >= 0) {\n            self.has_hxb2_links = d.hxb2_linked = true;\n          }\n\n    });\n\n     /* add buttons and handlers */\n     /* clusters first */\n\n     if (button_bar_ui) {\n\n        $('#' + button_bar_ui + '_cluster_zoom').on('show.bs.modal', function (event) {\n            var link_clicked = $(event.relatedTarget);\n            var cluster_id = link_clicked.data (\"cluster\");\n            var modal = d3.select ('#' + button_bar_ui + '_cluster_zoom');\n            modal.selectAll (\".modal-title\").text (\"Cluster \" + cluster_id);\n\n            $(\"#\" + button_bar_ui + \"_cluster_zoom_svg_export\").on (\"click\", function (e) {\n                datamonkey.save_image(\"png\", \"#\" + button_bar_ui + \"_cluster_zoom_svg\");\n            });\n\n            var node_indices = {};\n            var used_index   = 0;\n\n            var only_this_cluster = {\n                                        \"Nodes\" : _.map (_.filter (self.nodes, function (n,i) {if (n.cluster == cluster_id) {node_indices [i] = used_index++; return true;} return false;}), function (n) {var nn = _.clone (n); nn.cluster = 1; delete nn[\"parent\"]; return nn;}),\n                                        \"Edges\" : _.map (_.filter (self.edges, function (e) {\n                                            if (e.source in node_indices && e.target in node_indices) {\n                                                return true;\n                                            }\n                                            return false;\n                                        }), function (e) {var ne  = _.clone (e); ne.target = node_indices[ne.target]; ne.source = node_indices[ne.source]; return ne;}),\n\n                                     };\n\n\n            only_this_cluster[_networkGraphAttrbuteID] = self.json[_networkGraphAttrbuteID];\n\n\n            hivtrace_cluster_network_graph (only_this_cluster, \"#\" + button_bar_ui + \"_cluster_zoom_svg\", null, null, null, null, null, null, null, \"#\" + button_bar_ui + \"_cluster_zoom_body\",\n                    {\"expand\" : [1], \"charge\" : 10, \"colorizer\" : self.colorizer, \"node_shaper\" : self.node_shaper,  \"width\" : 600});\n\n        });\n\n         var cluster_ui_container = d3.select (\"#\" + button_bar_ui + \"_cluster_operations_container\");\n\n         [\n            [\"Expand All\",          function () {return self.expand_some_clusters()},   true, 'hivtrace-expand-all'],\n            [\"Collapse All\",        function () {return self.collapse_some_clusters()}, true, 'hivtrace-collapse-all'],\n            [\"Expand Filtered\",     function () {return self.expand_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))},   true, 'hivtrace-expand-filtered'],\n            [\"Collapse Filtered\",   function () {return self.collapse_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))}, true, 'hivtrace-collapse-filtered'],\n            [\"Hide problematic clusters\", function (item) {\n                                            d3.select (item).text (self.hide_hxb2 ? \"Hide problematic clusters\" :  \"Show problematic clusters\");\n                                            self.toggle_hxb2 ();\n                                          }, self.has_hxb2_links, 'hivtrace-hide-problematic-clusters'],\n\n            [\"Show removed edges\",   function (item) {\n                                        self.filter_edges = !self.filter_edges;\n                                        d3.select (item).text (self.filter_edges ? \"Show removed edges\" :  \"Hide removed edges\");\n                                        self.update (false);\n                                     }\n                                    , function () {return _.some (self.edges, function (d) {return d.removed;});}, 'hivtrace-show-removed-edges']\n\n         ].forEach (function (item,index) {\n            var handler_callback = item[1];\n            if (item[2]) {\n                this.append (\"li\").append (\"a\")\n                                  .text (item[0])\n                                  .attr (\"href\", \"#\")\n                                  .attr (\"id\", item[3])\n                                  .on (\"click\", function(e) {\n                                    handler_callback(this);\n                                    d3.event.preventDefault();\n                                  });\n            }\n         },cluster_ui_container);\n\n\n         var button_group  = d3.select (\"#\" + button_bar_ui + \"_button_group\");\n\n         if (! button_group.empty()) {\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Expand spacing\").on (\"click\", function (d) {change_spacing (5/4);}).append (\"i\").classed (\"fa fa-plus\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Compress spacing\").on (\"click\", function (d) {change_spacing (4/5);}).append (\"i\").classed (\"fa fa-minus\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Enlarge window\").on (\"click\", function (d) {change_window_size (20, true);}).append (\"i\").classed (\"fa fa-expand\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Shrink window\").on (\"click\", function (d) {change_window_size (-20, true);}).append (\"i\").classed (\"fa fa-compress\", true);\n\n            button_group.append (\"button\")\n              .classed(\"btn btn-default btn-sm\", true)\n              .attr(\"title\", \"Compute graph statistics\")\n              .attr(\"id\", \"hivtrace-compute-graph-statistics\")\n              .on(\"click\", function (d) {_.bind(self.compute_graph_stats,this)();})\n              .append(\"i\")\n              .classed(\"fa fa-calculator\", true);\n\n            button_group.append (\"button\")\n              .classed(\"btn btn-default btn-sm\", true)\n              .attr(\"title\", \"Save Image\")\n              .attr(\"id\", \"hivtrace-export-image\")\n              .on(\"click\", function(d) { datamonkey.save_image(\"png\", \"#network-svg\");})\n              .append (\"i\").classed (\"fa fa-image\", true);\n         }\n\n         $(\"#\" + button_bar_ui + \"_filter\").on (\"input propertychange\", _.throttle (function (e) {\n               var filter_value = $(this).val();\n               self.filter (filter_value.split (\" \").filter (function (d) {return d.length > 0;}).map (function (d) { return new RegExp (d,\"i\")}));\n            }, 250));\n\n    }\n\n\n     if (_networkGraphAttrbuteID in json) {\n        attributes = json[_networkGraphAttrbuteID];\n     } else {\n         if (attributes && \"hivtrace\" in attributes) {\n            attributes = attributes[\"hivtrace\"];\n         }\n    }\n\n     if (attributes) {\n         /*\n            map attributes into nodes and into the graph object itself using\n            _networkGraphAttrbuteID as the key\n         */\n\n         if (\"attribute_map\" in attributes) {\n             var attribute_map = attributes[\"attribute_map\"];\n\n             if (\"map\" in attribute_map && attribute_map[\"map\"].length > 0) {\n                 graph_data [_networkGraphAttrbuteID] = attribute_map[\"map\"].map (function (a,i) { return {'label': a, 'type' : null, 'values': {}, 'index' : i, 'range' : 0};});\n\n                 graph_data.Nodes.forEach (function (n) {\n                    n[_networkGraphAttrbuteID] = n.id.split (attribute_map[\"delimiter\"]);\n                    n[_networkGraphAttrbuteID].forEach (function (v,i) {\n                        if (i < graph_data [_networkGraphAttrbuteID].length) {\n                            if (! (v in graph_data [_networkGraphAttrbuteID][i][\"values\"])) {\n                                graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = graph_data [_networkGraphAttrbuteID][i][\"range\"];\n                                graph_data [_networkGraphAttrbuteID][i][\"range\"] += 1;\n                            }\n                        }\n                        //graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = 1 + (graph_data [_networkGraphAttrbuteID][i][\"values\"][v] ? graph_data [_networkGraphAttrbuteID][i][\"values\"][v] : 0);\n                    });\n                });\n\n                graph_data [_networkGraphAttrbuteID].forEach (function (d) {\n                    if (d['range'] < graph_data.Nodes.length && d['range'] > 1 &&d['range' ] <= 20) {\n                        d['type'] = 'category';\n                    }\n                });\n            }\n        }\n\n\n        // populate the UI elements\n        if (button_bar_ui) {\n            // decide if the variable can be considered categorical by examining its range\n\n\n            var valid_cats = _.filter (_.map (graph_data [_networkGraphAttrbuteID], function (d,k) {\n                d['raw_attribute_key'] = k;\n                if ('enum' in d || d['type'] == \"String\") {\n                    d['value_range'] = _.keys(_.countBy (graph_data.Nodes, function (nd) {\n                        return attribute_node_value_by_id (nd, k);\n                    }));\n                     d['dimension'] = d[\"value_range\"].length;\n                }\n\n                return d;\n            }), function (d) {\n                return 'value_range' in d && d['value_range'].length <= 15;\n            });\n\n            var valid_shapes = _.filter (valid_cats, function (d) {\n                 return d.dimension <= 5;\n            });\n\n            // sort values alphabetically for consistent coloring\n\n            _.each ([valid_cats, valid_shapes], function (list) {\n                _.each (list, function (d) {\n                    var values = d['value_range'].sort();\n                    var map    = new Object;\n\n                    _.each (values, function (d2, i) {\n                        map[d2] = i;\n                    });\n\n                    d['value_map'] = function (v,key) {return key ? (key == 'lookup' ? _.invert (map) : map) : map[v];};\n\n                })});\n\n\n            var valid_scales = _.filter (_.map (graph_data [_networkGraphAttrbuteID], function (d,k) {\n                d['raw_attribute_key'] = k;\n                if (d.type == \"Number\") {\n                    var values = _.filter (_.map (graph_data.Nodes, function (nd) {\n                        return attribute_node_value_by_id (nd, k);\n                     }), function (v) {\n                        return v == _networkMissing ? null : v;\n                    });\n                    // automatically determine the scale and see what spaces the values most evenly\n                    d['value_range'] = d3.extent (values);\n\n                     var low_var = Infinity;\n\n\n                    _.each ([d3.scale.linear(), d3.scale.log(), d3.scale.pow().exponent (1/3),  d3.scale.pow().exponent (0.25), d3.scale.pow().exponent (0.5),  d3.scale.pow().exponent (1/8),  d3.scale.pow().exponent (1/16)], function (scl) {\n                        var bins = _.map (_.range (_networkContinuousColorStops), function () {return 0.});\n                        scl.range ([0,_networkContinuousColorStops-1]).domain (d['value_range']);\n                        _.each (values, function (v) {\n                                bins[Math.floor (scl(v))] ++;\n                        });\n\n                        var mean = values.length / _networkContinuousColorStops;\n                        var vrnc = _.reduce (bins, function (p, c) {\n                            return p + (c-mean)*(c-mean);\n                        });\n\n                        if (vrnc < low_var) {\n                            low_var = vrnc;\n                            d['scale'] = scl;\n                        }\n\n                    });\n                }\n                return d;\n            }), function (d) {\n                return d.type == \"Number\";\n            });\n\n\n\n\n            //valid_cats.splice (0,0, {'label' : 'None', 'index' : -1});\n\n            [d3.select (\"#\" + button_bar_ui + \"_attributes\"),d3.select (\"#\" + button_bar_ui + \"_attributes_cat\")].forEach (function (m) {\n\n                m.selectAll (\"li\").remove();\n\n                var menu_items = [[['None',null,_.partial (handle_attribute_categorical,null)]],[['Categorical', 'heading',null]]].concat(valid_cats.map (function (d,i) {return [[d['label'],d['raw_attribute_key'],_.partial (handle_attribute_categorical, d['raw_attribute_key'])]];}));\n\n\n               if (valid_scales.length) {\n                    menu_items = menu_items.concat ([[['Continuous', 'heading',null]]]).concat (valid_scales.map (function (d,i) {return [[d['label'],d['raw_attribute_key'],\n                            _.partial (handle_attribute_continuous, d['raw_attribute_key'])]];}));\n                }\n\n                var cat_menu = m.selectAll (\"li\")\n                                .data(menu_items);\n\n\n                cat_menu.enter ().append (\"li\").classed (\"disabled\", function (d) {return d[0][1] == 'heading';}).style (\"font-variant\", function (d) {return d[0][1] < -1 ? \"small-caps\" : \"normal\";} );\n\n                cat_menu.selectAll (\"a\").data (function (d) {return d;})\n                                        .enter ()\n                                        .append (\"a\")\n                                        .text (function (d,i,j) {return d[0];})\n                                        .attr (\"style\", function (d,i,j) {if (d[1] == 'heading') return 'font-style: italic'; if (j == 0) { return ' font-weight: bold;'}; return null; })\n                                        .attr ('href', '#')\n                                        .on (\"click\", function (d) { if (d[2]) {d[2].call()}});\n            });\n\n            [d3.select (\"#\" + button_bar_ui + \"_shapes\")].forEach (function (m) {\n\n                m.selectAll (\"li\").remove();\n                var cat_menu = m.selectAll (\"li\")\n                                .data([[['None',null,_.partial (handle_shape_categorical,null)]]].concat(valid_shapes.map (function (d,i) {return [[d['label'],d['raw_attribute_key'],_.partial (handle_shape_categorical, d['raw_attribute_key'])]];})));\n\n                cat_menu.enter ().append (\"li\").style (\"font-variant\", function (d) {return d[0][1] < -1 ? \"small-caps\" : \"normal\";} );\n\n                cat_menu.selectAll (\"a\").data (function (d) {return d;})\n                                        .enter ()\n                                        .append (\"a\")\n                                        .text (function (d,i,j) {return d[0];})\n                                        .attr (\"style\", function (d,i,j) {if (j == 0) { return ' font-weight: bold;'}; return null; })\n                                        .attr ('href', '#')\n                                        .on (\"click\", function (d) { if (d[2]) {d[2].call()}});\n            });\n\n             $(\"#\" + button_bar_ui + \"_opacity_invert\").on (\"click\", function (e) {\n                if (self.colorizer ['opacity_scale']) {\n                    self.colorizer ['opacity_scale'].range (self.colorizer ['opacity_scale'].range().reverse());\n                    self.update(true);\n\n                }\n                $(this).toggleClass (\"btn-active btn-default\");\n\n             });\n\n             $(\"#\" + button_bar_ui + \"_attributes_invert\").on (\"click\", function (e) {\n                if (self.colorizer ['category_id']) {\n                    graph_data [_networkGraphAttrbuteID][self.colorizer ['category_id']]['scale'].range ( graph_data [_networkGraphAttrbuteID][self.colorizer ['category_id']]['scale'].range().reverse());\n                    self.clusters.forEach (function (the_cluster) {the_cluster[\"gradient\"] = compute_cluster_gradient (the_cluster, self.colorizer ['category_id']);});\n                    self.update(true);\n                    draw_attribute_labels();\n\n                }\n                $(this).toggleClass (\"btn-active btn-default\");\n\n             });\n\n             [d3.select (\"#\" + button_bar_ui + \"_opacity\")].forEach (function (m) {\n\n\n                m.selectAll (\"li\").remove();\n                var cat_menu = m.selectAll (\"li\")\n                                .data([[['None',null,_.partial (handle_attribute_opacity,null)]]].concat(valid_scales.map (function (d,i) {return [[d['label'],d['raw_attribute_key'],_.partial (handle_attribute_opacity, d['raw_attribute_key'])]];})));\n\n\n                cat_menu.enter ().append (\"li\").style (\"font-variant\", function (d) {return d[0][1] < -1 ? \"small-caps\" : \"normal\";} );\n                cat_menu.selectAll (\"a\").data (function (d) {return d;})\n                                        .enter ()\n                                        .append (\"a\")\n                                        .text (function (d,i,j) {return d[0];})\n                                        .attr (\"style\", function (d,i,j) {if (j == 0) { return ' font-weight: bold;'}; return null; })\n                                        .attr ('href', '#')\n                                        .on (\"click\", function (d) { if (d[2]) {d[2].call()}});\n            });\n\n        }\n    }\n\n    if (self.cluster_sizes.length > max_points_to_render) {\n      var sorted_array = self.cluster_sizes.map (function (d,i) {\n          return [d,i+1];\n        }).sort (function (a,b) {\n          return a[0] - b[0];\n        });\n\n      for (var k = 0; k < sorted_array.length - max_points_to_render; k++) {\n          exclude_cluster_ids[sorted_array[k][1]] = 1;\n      }\n      warning_string = \"Excluded \" + (sorted_array.length - max_points_to_render) + \" clusters (maximum size \" +  sorted_array[k-1][0] + \" nodes) because only \" + max_points_to_render + \" points can be shown at once.\";\n    }\n\n    // Initialize class attributes\n    singletons = graph_data.Nodes.filter (function (v,i) { return v.cluster === null; }).length; self.nodes = graph_data.Nodes.filter (function (v,i) { if (v.cluster && typeof exclude_cluster_ids[v.cluster]  === \"undefined\"  ) {connected_links[i] = total++; return true;} return false;  });\n    self.edges = graph_data.Edges.filter (function (v,i) { return connected_links[v.source] != undefined && connected_links[v.target] != undefined});\n    self.edges = self.edges.map (function (v,i) {v.source = connected_links[v.source]; v.target = connected_links[v.target]; v.id = i; return v;});\n\n    compute_node_degrees(self.nodes, self.edges);\n\n    var r = default_layout(self.clusters, self.nodes, exclude_cluster_ids);\n    self.clusters = r[0];\n    self.nodes = r[1];\n    self.clusters.forEach (function (d,i) {\n            cluster_mapping[d.cluster_id] = i;\n            d.hxb2_linked = d.children.some(function(c) {return c.hxb2_linked});\n            var degrees = d.children.map (function (c) {return c.degree;});\n            degrees.sort (d3.ascending);\n            d.degrees = datamonkey_describe_vector (degrees);\n            });\n\n\n    self.update();\n\n  }\n\n  function sort_table_toggle_icon (element, value) {\n    if (value) {\n        $(element).data (\"sorted\", value);\n        d3.select (element).selectAll (\"i\").classed (\"fa-sort-amount-desc\", value == \"desc\").classed (\"fa-sort-amount-asc\", value == \"asc\").classed (\"fa-sort\", value == \"unsorted\");\n    } else {\n        var sorted_state = $(element).data (\"sorted\");\n        sort_table_toggle_icon (element, sorted_state == \"asc\" ? \"desc\" : \"asc\");\n        return sorted_state == \"asc\" ? d3.descending: d3.ascending;\n    }\n  }\n\n  function sort_table_by_column (element, datum) {\n    d3.event.preventDefault();\n    var table_element = $(element).closest (\"table\");\n    if (table_element.length) {\n        var sort_on             = parseInt($(element).data (\"column-id\"));\n        var sort_key            = $(element).data (\"sort-on\");\n        var sorted_state        = ($(element).data (\"sorted\"));\n        var sorted_function     = sort_table_toggle_icon (element);\n\n        sort_accessor = sort_key ? function (x) {var val = x[sort_key]; if (typeof (val) === \"function\") return val (); return val;} : function (x) {return x;};\n\n        d3.select (table_element[0]).select (\"tbody\").selectAll (\"tr\").sort (function (a,b) { return sorted_function (sort_accessor(a[sort_on]), sort_accessor(b[sort_on]));});\n\n        // select all other elements from thead and toggle their icons\n\n        $(table_element).find (\"thead [data-column-id]\")\n                        .filter (function () {return parseInt ($(this).data (\"column-id\")) != sort_on;})\n                        .each (function () { sort_table_toggle_icon (this, \"unsorted\");});\n    }\n  }\n\n  function format_a_cell (data, index, item) {\n\n     var this_sel  = d3.select (item);\n\n     current_value = typeof (data.value) === \"function\" ? data.value() : data.value;\n\n     if (\"callback\" in data) {\n        data.callback (item, current_value);\n     } else {\n         var repr = \"format\" in data ?  data.format (current_value) : current_value;\n         if (\"html\" in data) this_sel.html (repr); else this_sel.text(repr);\n         if (\"sort\" in data) {\n            var clicker = this_sel.append (\"a\").property (\"href\", \"#\").on (\"click\", function (d) {sort_table_by_column (this, d);}).attr (\"data-sorted\", \"unsorted\").attr (\"data-column-id\", index).attr (\"data-sort-on\", data.sort);\n            clicker.append (\"i\").classed (\"fa fa-sort\", true).style (\"margin-left\", \"0.2em\");\n          }\n     }\n     if (\"help\" in data) {\n        this_sel.attr (\"title\", data.help);\n     }\n\n  }\n\n  function add_a_sortable_table (container, headers, content) {\n\n        var thead = container.selectAll (\"thead\");\n        if (thead.empty()) {\n            thead = container.append (\"thead\");\n            thead.selectAll (\"tr\").data (headers).enter().append (\"tr\").selectAll (\"th\").data (function (d) {return d;}).enter().append (\"th\").\n                                  call (function (selection) { return selection.each (function (d, i) {\n                                        format_a_cell (d, i, this);\n                                    })\n                                  });\n        }\n\n        var tbody = container.selectAll (\"tbody\");\n        if (tbody.empty()) {\n            tbody = container.append (\"tbody\");\n            tbody.selectAll (\"tr\").data (content).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").call (function (selection) { return selection.each (function (d, i) {\n                                        handle_cluster_click\n                                        format_a_cell (d, i, this);\n                                    })\n                                  });\n        }\n\n\n  }\n\n  function _cluster_table_draw_id (element, payload) {\n        var this_cell = d3.select (element);\n        var text = this_cell.selectAll (\"a\").data ([payload]);\n        text.enter ().append (\"a\");\n        text.exit().remove();\n        text.text (payload);\n        text.attr (\"href\", \"#\").attr (\"data-toggle\",\"modal\").attr(\"data-target\", \"#\" + button_bar_ui + \"_cluster_zoom\").attr (\"data-cluster\", payload);\n  }\n\n  function _cluster_table_draw_buttons (element, payload) {\n    var this_cell = d3.select (element);\n    var labels = [[payload[0] ? \"collapsed\" : \"expanded\",0]];\n    if (payload[1]) {\n        labels.push ([\"problematic\",1]);\n    }\n    var buttons = this_cell.selectAll (\"button\").data (labels);\n    buttons.enter().append (\"button\");\n    buttons.exit().remove();\n    buttons.classed (\"btn btn-primary btn-xs\", true).text (function (d) {return d[0];})\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\n                                                 .on (\"click\", function (d) {\n                                                    if (d[1] == 0) {\n                                                        if (payload[0]) {\n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1], true);\n                                                        } else {\n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1]);\n                                                        }\n                                                        format_a_cell (d3.select (element).datum(), null, element);\n                                                    }\n                                                 });\n\n  };\n\n function _node_table_draw_buttons (element, payload) {\n    var this_cell = d3.select (element);\n    var labels = [[payload[0] ? \"shown\" : \"hidden\",0]];\n\n    var buttons = this_cell.selectAll (\"button\").data (labels);\n    buttons.enter().append (\"button\");\n    buttons.exit().remove();\n    buttons.classed (\"btn btn-primary btn-xs btn-node-property\", true).text (function (d) {return d[0];})\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\n                                                 .on (\"click\", function (d) {\n                                                    if (d[1] == 0) {\n                                                        if (payload[0]) {\n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1], true);\n                                                        } else {\n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1]);\n                                                        }\n                                                        format_a_cell (d3.select (element).datum(), null, element);\n                                                    }\n                                                 });\n\n  };\n\n  self.update_volatile_elements = function (container) {\n    container.selectAll (\"td\").filter (function (d,i) {\n        return (\"volatile\" in d);\n    }).each (function (d,i) {\n        format_a_cell (d, i, this);\n    });\n  };\n\n  function draw_node_table () {\n\n    if (self.node_table) {\n        add_a_sortable_table (self.node_table,\n                                // headers\n                              [[{value:\"ID\", sort : \"value\", help: \"Node ID\"},\n                                 {value: \"Properties\", sort: \"value\"},\n                                 {value: \"Degree\", sort: \"value\", help: \"Node degree\"},\n                                 {value: \"Cluster\", sort: \"value\", help: \"Which cluster does the node belong to\"},\n                                 {value: \"LCC\", sort: \"value\", help: \"Local clustering coefficient\"}\n                               ]],\n                                 // rows\n                               self.nodes.map (function (n, i) {\n                                return [{\"value\": n.id, help: \"Node ID\"},\n                                        {       \"value\": function () {return [!self.clusters [n.cluster-1].collapsed, n.cluster]},\n                                                \"callback\": _node_table_draw_buttons,\n                                                \"volatile\" : true\n                                        },\n                                        {\"value\" : n.degree, help: \"Node degree\"},\n                                        {\"value\" : n.cluster, help: \"Which cluster does the node belong to\"},\n                                        {\"value\": function () {return datamonkey.hivtrace.format_value(n.lcc,_defaultFloatFormat);},\n                                         \"volatile\" : true, \"html\": true, help: \"Local clustering coefficient\"}];\n\n                                }));\n    }\n  }\n\n  function draw_cluster_table () {\n    if (self.cluster_table) {\n        add_a_sortable_table (self.cluster_table,\n                                // headers\n                              [[{value:\"ID (click to zoom)\", sort : \"value\", help: \"Unique cluster ID\"},\n                                 {value: \"Properties\", sort: \"value\"},\n                                 {value: \"Size\", sort: \"value\", help: \"Number of nodes in the cluster\"},\n                                 {value: \"Degrees<br>Mean [Median, IQR]\", html : true},\n                                 {value: \"CC\", sort: \"value\", help: \"Global clustering coefficient\"},\n                                 {value: \"MPL\", sort: \"value\", help: \"Mean Path Length\"}\n                               ]],\n                                self.clusters.map (function (d, i) {\n                                 // rows\n                                return [{value: d.cluster_id,\n                                         callback: _cluster_table_draw_id},\n                                        {       value: function () {return [d.collapsed, d.hxb2_linked, d.cluster_id]},\n                                                callback: _cluster_table_draw_buttons,\n                                                volatile : true\n                                        },\n                                        {value :d.children.length},\n                                        {value : d.degrees, format: function (d) {return _defaultFloatFormat(d['mean']) + \" [\" + _defaultFloatFormat(d['median']) + \", \" + _defaultFloatFormat(d['Q1']) + \" - \" + _defaultFloatFormat(d['Q3']) +\"]\"}},\n                                        {\n                                            value: function () {return hivtrace_format_value(d.cc,_defaultFloatFormat);},\n                                            volatile : true,\n                                            help: \"Global clustering coefficient\"\n                                        },\n                                        {\n                                            value: function () {return hivtrace_format_value(d.mpl,_defaultFloatFormat);},\n                                            volatile : true,\n                                            help: \"Mean path length\"\n                                        }\n                                        ];\n\n                                })\n                                );\n        }\n  }\n\n  /*------------ Update layout code ---------------*/\n  function update_network_string (draw_me) {\n      if (network_status_string) {\n          var clusters_shown = self.clusters.length-draw_me.clusters.length,\n              clusters_removed = self.cluster_sizes.length - self.clusters.length,\n              nodes_removed = graph_data.Nodes.length - singletons - self.nodes.length;\n\n          var s = \"Displaying a network on <strong>\" + self.nodes.length + \"</strong> nodes, <strong>\" + self.clusters.length + \"</strong> clusters\"\n                  + (clusters_removed > 0 ? \" (an additional \" + clusters_removed + \" clusters and \" + nodes_removed + \" nodes have been removed due to network size constraints)\" : \"\") + \". <strong>\"\n                  + clusters_shown +\"</strong> clusters are expanded. Of <strong>\" + self.edges.length + \"</strong> edges, <strong>\" + draw_me.edges.length + \"</strong>, and of  <strong>\" + self.nodes.length  + \" </strong> nodes,  <strong>\" + draw_me.nodes.length + \" </strong> are displayed. \";\n          if (singletons > 0) {\n              s += \"<strong>\" +singletons + \"</strong> singleton nodes are not shown. \";\n          }\n          d3.select (network_status_string).html(s);\n    }\n  }\n\n\n  function draw_a_node (container, node) {\n    container = d3.select(container);\n\n    var symbol_type =  (node.hxb2_linked && !node.is_lanl) ? \"cross\" : (node.is_lanl ? \"triangle-down\" : self.node_shaper['shaper'] (node));\n\n    container.attr(\"d\", datamonkey.hivtrace.symbol (symbol_type).size( node_size (node) ))\n        .attr('class', 'node')\n        .attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\n        .style('fill', function(d) { return node_color(d); })\n        .style('opacity', function (d) {return node_opacity(d);})\n        .on ('click', handle_node_click)\n        .on ('mouseover', node_pop_on)\n        .on ('mouseout', node_pop_off)\n        .call(network_layout.drag().on('dragstart', node_pop_off));\n\n   }\n\n\n  function draw_a_cluster (container, the_cluster) {\n\n     container_group = d3.select(container);\n\n     var draw_from   = the_cluster[\"binned_attributes\"] ? the_cluster[\"binned_attributes\"].map (function (d) {return d.concat ([0]);}) : [[null, 1, 0]];\n\n     if (the_cluster.match_filter) {\n        draw_from = draw_from.concat ([[\"selected\",the_cluster.match_filter,1],[\"not selected\",the_cluster.children.length - the_cluster.match_filter,1]]);\n     }\n\n     var sums  = [d3.sum(draw_from.filter (function (d) {return d[2] == 0}),function (d) {return d[1];}),\n                  d3.sum(draw_from.filter (function (d) {return d[2] != 0}),function (d) {return d[1];})];\n\n     var running_totals = [0,0];\n\n     draw_from = draw_from.map (function (d) {  index = d[2];\n                                                var v = {'container' : container,\n                                                        'cluster': the_cluster,\n                                                        'startAngle' : running_totals[index]/sums[index]*2*Math.PI,\n                                                        'endAngle': (running_totals[index]+d[1])/sums[index]*2*Math.PI,\n                                                        'name': d[0],\n                                                        'rim' : index > 0};\n                                                 running_totals[index] += d[1];\n                                                 return v;\n\n                                             });\n\n\n     var arc_radius = cluster_box_size(the_cluster)*0.5;\n     var paths = container_group.selectAll (\"path\").data (draw_from);\n     paths.enter ().append (\"path\");\n     paths.exit  ().remove();\n\n     paths.classed (\"cluster\", true)\n          .classed (\"hiv-trace-problematic\", function (d) {return the_cluster.hxb2_linked && !d.rim;})\n          .classed (\"hiv-trace-selected\", function (d) {return d.rim;})\n          .attr (\"d\", function (d) {\n                return (d.rim\n                        ? d3.svg.arc().innerRadius(arc_radius+2).outerRadius(arc_radius+5)\n                        : d3.svg.arc().innerRadius(0).outerRadius(arc_radius))(d);\n                })\n          .style (\"fill\", function (d,i) {return d.rim ? self.colorizer ['selected'] (d.name) : (the_cluster[\"gradient\"] ? 'url(#' + the_cluster[\"gradient\"] + ')' : cluster_color (the_cluster, d.name));})\n          ;\n\n\n\n  }\n\n  function handle_shape_categorical (cat_id) {\n        var set_attr = \"None\";\n\n        [\"#\" + button_bar_ui + \"_shapes\"].forEach (function (m) {\n            d3.select (m).selectAll (\"li\").selectAll (\"a\").attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\n            d3.select (m + \"_label\").html (\"Shape: \" + set_attr + ' <span class=\"caret\"></span>');\n        });\n\n\n         if (cat_id) {\n            var shape_mapper = d3.scale.ordinal().domain (_.range (0,graph_data [_networkGraphAttrbuteID][cat_id].dimension)).range (_networkShapeOrdering);\n            self.node_shaper['id'] = cat_id;\n            self.node_shaper['shaper'] = function (d) {return shape_mapper (graph_data [_networkGraphAttrbuteID][cat_id]['value_map'](attribute_node_value_by_id(d,cat_id)));} ;\n            self.node_shaper['category_map'] = graph_data [_networkGraphAttrbuteID][cat_id]['value_map'];\n        } else {\n            self.node_shaper.id = null;\n            self.node_shaper.shaper = function () { return 'circle' };\n            self.node_shaper['category_map'] = null;\n        }\n        //console.log (graph_data [_networkGraphAttrbuteID][cat_id]['value_map'], self.node_shaper.domain(), self.node_shaper.range());\n        draw_attribute_labels();\n        self.update(true);\n        d3.event.preventDefault();\n  }\n\n  function draw_attribute_labels () {\n\n        legend_svg.selectAll (\"g.hiv-trace-legend\").remove();\n        var offset = 10;\n\n        if (self.colorizer['category_id']) {\n            legend_svg.append (\"g\").attr (\"transform\", \"translate(0,\" + offset + \")\").classed ('hiv-trace-legend',true).append (\"text\").text (self.colorizer['category_id']).style (\"font-weight\", \"bold\");\n            offset += 18;\n\n            if (self.colorizer[\"continuous\"]) {\n                var anchor_format = d3.format(\",.4r\");\n                var scale = graph_data [_networkGraphAttrbuteID][self.colorizer['category_id']]['scale'];\n\n                _.each (_.range (_networkContinuousColorStops), function (value) {\n                     var x =  scale.invert (value);\n                     legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(20,\" + offset + \")\").append (\"text\").text (anchor_format(x));\n                     legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(0,\" + offset + \")\").append (\"circle\").attr (\"cx\", \"8\")\n                                    .attr (\"cy\", \"-4\").attr (\"r\",\"8\").classed (\"legend\",true).style (\"fill\", self.colorizer['category'](x));\n\n                     offset += 18;\n                });\n\n                legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(20,\" + offset + \")\").append (\"text\").text (\"missing\");\n                legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(0,\" + offset + \")\").append (\"circle\").attr (\"cx\", \"8\")\n                                .attr (\"cy\", \"-4\").attr (\"r\",\"8\").classed (\"legend\",true).style (\"fill\", _networkMissingColor);\n\n                offset += 18;\n            } else {\n                _.each (self.colorizer['category_map'](null,'map'), function (value, key) {\n                     legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(20,\" + offset + \")\").append (\"text\").text (key);\n                     legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(0,\" + offset + \")\").append (\"circle\").attr (\"cx\", \"8\").attr (\"cy\", \"-4\").attr (\"r\",\"8\").classed (\"legend\",true).style (\"fill\", self.colorizer['category'](key));\n\n                     offset += 18;\n                });\n            }\n        }\n\n        if (self.node_shaper['id']) {\n            legend_svg.append (\"g\").attr (\"transform\", \"translate(0,\" + offset + \")\").classed ('hiv-trace-legend',true).append (\"text\").text (self.node_shaper['id']).style (\"font-weight\", \"bold\");\n            offset += 18;\n\n            console.log (self.node_shaper['id'], graph_data [_networkGraphAttrbuteID]);\n\n            var shape_mapper = d3.scale.ordinal().domain (_.range (0,graph_data [_networkGraphAttrbuteID][self.node_shaper['id']].dimension)).range (_networkShapeOrdering);\n\n            _.each (self.node_shaper['category_map'](null,'map'), function (value, key) {\n                 legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(20,\" + offset + \")\").append (\"text\").text (key);\n\n                 legend_svg.append (\"g\").classed ('hiv-trace-legend',true).attr (\"transform\", \"translate(0,\" + offset + \")\").append (\"path\")\n                                                                          .attr (\"transform\", \"translate(5,-5)\")\n                                                                          .attr(\"d\",  datamonkey.hivtrace.symbol(shape_mapper (value)).size( 128 ))\n                                                                          .classed('legend', true)\n                                                                          .style ('fill', 'none');\n\n                 offset += 18;\n            });\n        }\n  }\n\n  function compute_cluster_gradient (cluster, cat_id) {\n        if (cat_id) {\n            var id = \"hivtrace-cluster-gradient-\" + (self.gradient_id++);\n            var gradient = network_svg.selectAll(\"defs\").append (\"radialGradient\").attr (\"id\", id);\n            var values = _.map (cluster.children, function (node) {var value = attribute_node_value_by_id (node, cat_id); return value == _networkMissing ? Infinity : value;}).sort(function (a,b) {return (0+a) - (0+b);});\n            var finite = _.filter (values, function (d) {return d < Infinity; });\n            var infinite = values.length - finite.length;\n\n\n            if (infinite) {\n                gradient.append (\"stop\").attr (\"offset\", \"0%\").attr (\"stop-color\", _networkMissingColor);\n                gradient.append (\"stop\").attr (\"offset\", \"\" + (infinite/values.length * 100) + \"%\").attr (\"stop-color\", _networkMissingColor);\n            }\n\n\n            _.each (finite, function (value, index) {\n                   gradient.append (\"stop\").attr (\"offset\", \"\" + ((1+index+infinite) * 100) / values.length + \"%\").attr (\"stop-color\", self.colorizer['category'] (value));\n            });\n            //gradient.append (\"stop\").attr (\"offset\", \"100%\").attr (\"stop-color\", self.colorizer['category'] (dom[1]));\n\n\n            return id;\n        }\n        return null;\n  }\n\n  function handle_attribute_opacity (cat_id) {\n    var set_attr = \"None\";\n\n    [\"#\" + button_bar_ui + \"_opacity\"].forEach (function (m) {\n        d3.select (m).selectAll (\"li\").selectAll (\"a\").attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\n        d3.select (m + \"_label\").html (\"Opacity: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n    d3.select (\"#\" + button_bar_ui + \"_opacity_invert\").style (\"display\", set_attr == \"None\" ? \"none\" : \"inline\").classed (\"btn-active\",false).classed (\"btn-default\",true);\n\n\n\n    self.colorizer['opacity_id']       = cat_id;\n    if (cat_id) {\n        var scale = graph_data [_networkGraphAttrbuteID][cat_id]['scale'];\n        self.colorizer['opacity_scale'] = d3.scale.linear ().domain ([0,_networkContinuousColorStops-1]).range ([0.25,1]);\n        self.colorizer['opacity']          = function (v) {\n                if ( v == _networkMissing) {\n                    return _networkMissingOpacity;\n                }\n                return self.colorizer['opacity_scale'] (scale(v));\n            };\n    } else {\n        self.colorizer['opacity']          = null;\n        self.colorizer['opacity_scale']          = null;\n    }\n\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n  }\n\n  function handle_attribute_continuous (cat_id) {\n    var set_attr = \"None\";\n\n    render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\n    render_binned_table  (\"#\" + button_bar_ui + \"_attribute_table\", null, null);\n\n    network_svg.selectAll (\"radialGradient\").remove();\n\n    self.clusters.forEach (function (the_cluster) {delete the_cluster['binned_attributes']; delete the_cluster[\"gradient\"]});\n\n    [\"#\" + button_bar_ui + \"_attributes\",\"#\" + button_bar_ui + \"_attributes_cat\"].forEach (function (m) {\n        d3.select (m).selectAll (\"li\").selectAll (\"a\").attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\n        d3.select (m + \"_label\").html (\"Color: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n    d3.select (\"#\" + button_bar_ui + \"_attributes_invert\").style (\"display\", set_attr == \"None\" ? \"none\" : \"inline\").classed (\"btn-active\",false).classed (\"btn-default\",true);\n\n    if (cat_id) {\n        //console.log (graph_data [_networkGraphAttrbuteID][cat_id]);\n\n\n        self.colorizer['category']    = _.wrap (d3.scale.linear().range([\"#fff7ec\", \"#fee8c8\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#b30000\", \"#7f0000\"]).domain (_.range(_networkContinuousColorStops)),\n                         function (func, arg) {\n                            return func (graph_data [_networkGraphAttrbuteID][cat_id]['scale'](arg));\n                         });        //console.log (self.colorizer['category'].exponent ());\n\n        //console.log (self.colorizer['category'] (graph_data [_networkGraphAttrbuteID][cat_id]['value_range'][0]), self.colorizer['category'] (d['value_range'][1]));\n\n        self.colorizer['category_id'] = cat_id;\n        self.colorizer['continuous'] = true;\n        self.clusters.forEach (function (the_cluster) {the_cluster[\"gradient\"] = compute_cluster_gradient (the_cluster, cat_id);});\n\n\n        var points = [];\n\n        _.each (self.edges, function (e) {\n\n\n            var src  = attribute_node_value_by_id(self.nodes[e.source], cat_id),\n                tgt =  attribute_node_value_by_id(self.nodes[e.target], cat_id);\n\n            if (src != _networkMissing && tgt != _networkMissing) {\n                points.push ({x : src, y : tgt, title: self.nodes[e.source].id + \" (\" + src + \") -- \" + self.nodes[e.target].id + \" (\" + tgt + \")\"});\n            }\n        });\n\n        datamonkey.hivtrace.scatterplot (points, 400, 400, \"#\" + button_bar_ui + \"_aux_svg_holder\", {x : \"Source\", y : \"Target\"});\n\n    } else {\n        self.colorizer['category']          = null;\n        self.colorizer['category_id']       = null;\n        self.colorizer['continuous']        = false;\n        self.colorizer['category_pairwise'] = null;\n        self.colorizer['category_map']      = null;\n    }\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n\n  }\n\n  function handle_attribute_categorical (cat_id) {\n\n    //console.log (cat_id, graph_data [_networkGraphAttrbuteID]);\n\n    var set_attr = \"None\";\n       d3.select (\"#\" + button_bar_ui + \"_attributes_invert\").style (\"display\", \"none\");\n\n    network_svg.selectAll (\"radialGradient\").remove();\n\n    [\"#\" + button_bar_ui + \"_attributes\",\"#\" + button_bar_ui + \"_attributes_cat\"].forEach (function (m) {\n        d3.select (m).selectAll (\"li\").selectAll (\"a\").attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\n        d3.select (m + \"_label\").html (\"Color: \" + set_attr + ' <span class=\"caret\"></span>');\n    });\n\n     self.clusters.forEach (function (the_cluster) {delete the_cluster[\"gradient\"]; the_cluster['binned_attributes'] = stratify(attribute_cluster_distribution (the_cluster, cat_id)); });\n\n\n     self.colorizer['continuous']        = false;\n\n     if (cat_id) {\n        if (cat_id in _networkPresetColorSchemes) {\n            var domain = [], range = [];\n            _.each (_networkPresetColorSchemes[cat_id], function (value, key) {\n                domain.push (key);\n                range.push (value);\n            });\n            self.colorizer['category'] = d3.scale.ordinal ().domain (domain).range (range);\n\n        } else {\n            self.colorizer['category']    = graph_data [_networkGraphAttrbuteID][cat_id].dimension <= 10 ? d3.scale.category10() : d3.scale.category20c();\n        }\n        self.colorizer['category_id'] = cat_id;\n        self.colorizer['category_map'] = graph_data [_networkGraphAttrbuteID][cat_id]['value_map'];\n        //self.colorizer['category_map'][null] =  graph_data [_networkGraphAttrbuteID][cat_id]['range'];\n        self.colorizer['category_pairwise'] = attribute_pairwise_distribution(cat_id, graph_data [_networkGraphAttrbuteID][cat_id].dimension, self.colorizer['category_map']);\n\n\n\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribute_table\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n    } else {\n        self.colorizer['category']          = null;\n        self.colorizer['category_id']       = null;\n        self.colorizer['category_pairwise'] = null;\n        self.colorizer['category_map']      = null;\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribute_table\", null, null);\n    }\n\n    draw_attribute_labels();\n    self.update(true);\n    d3.event.preventDefault();\n  }\n\n  self.filter = function (expressions, skip_update) {\n\n    var anything_changed = false;\n\n    self.clusters.forEach (function (c) {\n        c.match_filter = 0;\n    });\n\n    self.nodes.forEach (function (n) {\n        var did_match = _.some(expressions, function (regexp) {\n            return regexp.test (n.id) || _.some (n[_networkNodeAttributeID], function (attr) {return regexp.test (attr)});\n        });\n\n        if (did_match != n.match_filter) {\n            n.match_filter = did_match;\n            anything_changed = true;\n        }\n\n        if (n.match_filter) {\n            n.parent.match_filter += 1;\n        }\n    });\n\n\n    if (anything_changed && !skip_update) {\n        self.update (true);\n    }\n\n  }\n\n  self.update = function (soft, friction) {\n\n    self.needs_an_update = false;\n\n    if (friction) {\n        network_layout.friction (friction);\n    }\n    if (network_warning_tag) {\n        if (warning_string.length) {\n          d3.select (network_warning_tag).text (warning_string).style (\"display\", \"block\");\n          warning_string = \"\";\n        } else {\n          d3.select (network_warning_tag).style (\"display\", \"none\");\n        }\n    }\n\n    var rendered_nodes,\n        rendered_clusters,\n        link;\n\n    if (!soft) {\n\n        var draw_me = prepare_data_to_graph();\n\n\n        network_layout.nodes(draw_me.all)\n            .links(draw_me.edges)\n            .start ();\n\n        update_network_string(draw_me);\n\n        link = network_svg.selectAll(\".link\")\n            .data(draw_me.edges, function (d) {return d.id;});\n\n        link.enter().append(\"line\")\n            .classed (\"link\", true);\n        link.exit().remove();\n\n        link.classed (\"removed\", function (d) {return d.removed;})\n            .classed (\"unsupported\", function (d) { return \"support\" in d && d[\"support\"] > 0.05;})\n            .on (\"mouseover\", edge_pop_on)\n            .on (\"mouseout\", edge_pop_off)\n            .filter (function (d) {return d.directed;})\n            .attr(\"marker-end\", \"url(#arrowhead)\");\n\n\n        rendered_nodes  = network_svg.selectAll('.node')\n            .data(draw_me.nodes, function (d) {return d.id;});\n        rendered_nodes.exit().remove();\n        rendered_nodes.enter().append(\"path\");\n\n        rendered_clusters = network_svg.selectAll (\".cluster-group\").\n          data(draw_me.clusters.map (function (d) {return d;}), function (d) {return d.cluster_id;});\n\n        rendered_clusters.exit().remove();\n        rendered_clusters.enter().append (\"g\").attr (\"class\", \"cluster-group\")\n              .attr (\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\n              .on (\"click\", handle_cluster_click)\n              .on (\"mouseover\", cluster_pop_on)\n              .on (\"mouseout\", cluster_pop_off)\n              .call(network_layout.drag().on(\"dragstart\", cluster_pop_off));\n\n        draw_cluster_table();\n        draw_node_table();\n\n    } else {\n        rendered_nodes = network_svg.selectAll('.node');\n        rendered_clusters = network_svg.selectAll (\".cluster-group\");\n        link = network_svg.selectAll(\".link\");\n    }\n\n    rendered_nodes.each (function (d) {\n              draw_a_node (this, d);\n             });\n\n    rendered_clusters.each (function (d) {\n        draw_a_cluster (this, d);\n    });\n\n    link.style (\"opacity\", function (d) {return Math.max (node_opacity (d.target), node_opacity (d.source))})\n\n\n\n    if (!soft) {\n        currently_displayed_objects = rendered_clusters[0].length + rendered_nodes[0].length;\n\n        network_layout.on(\"tick\", function() {\n          var sizes = network_layout.size();\n\n          rendered_nodes.attr(\"transform\", function(d) { return \"translate(\" + (d.x = Math.max(10, Math.min(sizes[0] - 10, d.x))) + \",\" + (d.y = Math.max(10, Math.min(sizes[1] - 10, d.y)))+ \")\"; });\n          rendered_clusters.attr(\"transform\", function(d) { return \"translate(\" + (d.x = Math.max(10, Math.min(sizes[0] - 10, d.x))) + \",\" + (d.y = Math.max(10, Math.min(sizes[1] - 10, d.y))) + \")\"; });\n\n          link.attr(\"x1\", function(d) { return d.source.x; })\n              .attr(\"y1\", function(d) { return d.source.y; })\n              .attr(\"x2\", function(d) { return d.target.x; })\n              .attr(\"y2\", function(d) { return d.target.y; });\n        });\n    }\n  }\n\n  function tick() {\n    var sizes = network_layout.size();\n\n    node.attr(\"cx\", function(d) { return d.x = Math.max(10, Math.min(sizes[0] - 10, d.x)); })\n        .attr(\"cy\", function(d) { return d.y = Math.max(10, Math.min(sizes[1] - 10, d.y)); });\n\n    link.attr(\"x1\", function(d) { return d.source.x; })\n        .attr(\"y1\", function(d) { return d.source.y; })\n        .attr(\"x2\", function(d) { return d.target.x; })\n        .attr(\"y2\", function(d) { return d.target.y; });\n\n  }\n\n  /*------------ Node Methods ---------------*/\n  function compute_node_degrees(nodes, edges) {\n      for (var n in nodes) {\n          nodes[n].degree = 0;\n      }\n\n      for (var e in edges) {\n          nodes[edges[e].source].degree++;\n          nodes[edges[e].target].degree++;\n      }\n  }\n\n\n  function  attribute_node_value_by_id (d, id) {\n     if (_networkNodeAttributeID in d && id) {\n        if (id in d[_networkNodeAttributeID]) {\n            var v = d[_networkNodeAttributeID][id];\n            if (_.isString (v) && v.length == 0) {\n                return _networkMissing;\n            }\n            return v;\n        }\n     }\n     return _networkMissing;\n  }\n\n\n  function node_size (d) {\n    var r = 5+Math.sqrt(d.degree); return (d.match_filter ? 10 : 4)*r*r;\n  }\n\n  function node_color(d) {\n\n    if (d.match_filter) {\n        return \"white\";\n    }\n\n    if (self.colorizer['category_id']) {\n        var v = attribute_node_value_by_id (d, self.colorizer['category_id']);\n        if (self.colorizer['continuous']) {\n            if (v == _networkMissing) {\n                return _networkMissingColor;\n            }\n        }\n        return self.colorizer['category'](v);\n\n    }\n    return d.hxb2_linked ? \"black\" : (d.is_lanl ? \"red\" : \"gray\");\n  }\n\n function node_opacity(d) {\n    if (self.colorizer['opacity']) {\n        return self.colorizer ['opacity'] (attribute_node_value_by_id (d, self.colorizer['opacity_id']));\n    }\n    return 1.;\n  }\n\n  function cluster_color(d, type) {\n    if (d[\"binned_attributes\"]) {\n        return self.colorizer['category'](type);\n    }\n    return \"#bdbdbd\";\n  }\n\n  function hxb2_node_color(d) {\n    return \"black\";\n  }\n\n  function node_info_string (n) {\n      var str = \"Degree <em>\" + n.degree + \"</em>\"+\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (n.lcc, _defaultFloatFormat) + \"</em>\";\n\n      if (self.colorizer['category_id']) {\n          var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\n          if (attribute) {\n             str += \"<br>\"  + self.colorizer['category_id'] + \" <em>\" + attribute + \"</em>\"\n          }\n      }\n      return str;\n  }\n\n  function edge_info_string (n) {\n     var str = \"Length <em>\" + _defaultFloatFormat(n.length) + \"</em>\";\n     if (\"support\" in n) {\n        str += \"<br>Worst triangle-based support (p): <em>\" + _defaultFloatFormat(n.support) + \"</em>\";\n     }\n\n      var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\n\n      return str;\n  }\n\n  function node_pop_on (d) {\n      toggle_tooltip (this, true, \"Node \" + d.id, node_info_string (d));\n  }\n\n  function node_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n  function edge_pop_on (e) {\n      toggle_tooltip (this, true, e.source.id + \" - \" + e.target.id, edge_info_string (e));\n  }\n\n  function edge_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n\n  /*------------ Cluster Methods ---------------*/\n\n  function compute_cluster_centroids (clusters) {\n      for (var c in clusters) {\n          var cls = clusters[c];\n          cls.x = 0.;\n          cls.y = 0.;\n          cls.children.forEach (function (x) { cls.x += x.x; cls.y += x.y; });\n          cls.x /= cls.children.length;\n          cls.y /= cls.children.length;\n      }\n  }\n\n  function collapse_cluster(x, keep_in_q) {\n      self.needs_an_update = true;\n      x.collapsed = true;\n      currently_displayed_objects -= self.cluster_sizes[x.cluster_id-1]-1;\n      if (!keep_in_q) {\n          var idx = open_cluster_queue.indexOf(x.cluster_id);\n          if (idx >= 0) {\n           open_cluster_queue.splice (idx,1);\n          }\n      }\n      compute_cluster_centroids ([x]);\n      return x.children.length;\n  }\n\n  function expand_cluster (x, copy_coord) {\n      self.needs_an_update = true;\n      x.collapsed = false;\n      currently_displayed_objects += self.cluster_sizes[x.cluster_id-1]-1;\n      open_cluster_queue.push (x.cluster_id);\n      if (copy_coord) {\n          x.children.forEach (function (n) { n.x = x.x + (Math.random()-0.5)*x.children.length; n.y = x.y + (Math.random()-0.5)*x.children.length; });\n      } else {\n          x.children.forEach (function (n) { n.x = self.width * 0.25 + (Math.random()-0.5)*x.children.length; n.y = 0.25*self.height + (Math.random()-0.5)*x.children.length; })\n      }\n  }\n\n  function render_binned_table (id, the_map, matrix) {\n\n    var the_table = d3.select (id);\n\n    the_table.selectAll (\"thead\").remove();\n    the_table.selectAll (\"tbody\").remove();\n\n    if (matrix) {\n\n        var fill = self.colorizer['category'];\n        lookup =  the_map(null, 'lookup');\n\n\n        var headers = the_table.append (\"thead\").append (\"tr\")\n                      .selectAll (\"th\").data ([\"\"].concat (matrix[0].map (function (d,i) {return lookup [i];})));\n\n        headers.enter().append (\"th\");\n        headers.html (function (d) { return \"<span>&nbsp;\" + d + \"</span>\";}).each (\n            function (d,i) {\n                if (i) {\n                    d3.select (this).insert (\"i\",\":first-child\")\n                        .classed (\"fa fa-circle\", true)\n                        .style (\"color\", function () {return fill (d);});\n                }\n            }\n        );\n\n        var rows = the_table.append (\"tbody\").selectAll (\"tr\").data (matrix.map (function (d, i) {return [lookup[i]].concat (d);}));\n        rows.enter ().append (\"tr\");\n        rows.selectAll (\"td\").data (function (d) {return d}).enter().append (\"td\").html (function (d, i) {\n            return i == 0 ? (\"<span>&nbsp;\" + d + \"</span>\") : d;\n        }).each (function (d, i) {\n                if (i == 0) {\n                    d3.select (this).insert (\"i\",\":first-child\")\n                        .classed (\"fa fa-circle\", true)\n                        .style (\"color\", function () {return fill (d);});\n                }\n\n        });\n\n\n\n    }\n  }\n\n  function render_chord_diagram (id, the_map, matrix) {\n\n        d3.select (id).selectAll (\"svg\").remove();\n        if (matrix) {\n\n            lookup = the_map(null, 'lookup');\n\n\n            var svg = d3.select (id).append (\"svg\");\n\n\n            var chord = d3.layout.chord()\n                .padding(.05)\n                .sortSubgroups(d3.descending)\n                .matrix(matrix);\n\n            var text_offset = 20,\n                width  = 450,\n                height = 450,\n                innerRadius = Math.min(width, height-text_offset) * .41,\n                outerRadius = innerRadius * 1.1;\n\n            var fill = self.colorizer['category'],\n                font_size = 12;\n\n\n\n            var text_label = svg.append (\"g\")\n                                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset)  + \")\")\n                                .append (\"text\")\n                                .attr (\"text-anchor\", \"middle\")\n                                .attr (\"font-size\", font_size)\n                                .text (\"\");\n\n            svg = svg.attr(\"width\", width)\n                .attr(\"height\", height-text_offset)\n                .append(\"g\")\n                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset) / 2 + \")\");\n\n\n            svg.append(\"g\").selectAll(\"path\")\n                .data(chord.groups)\n              .enter().append(\"path\")\n                .style(\"fill\", function(d)   { return fill(lookup[d.index]); })\n                .style(\"stroke\", function(d) { return fill(lookup[d.index]); })\n                .attr(\"d\", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))\n                .on(\"mouseover\", fade(0.1,true))\n                .on(\"mouseout\", fade(1,false));\n\n\n\n            svg.append(\"g\")\n                .attr(\"class\", \"chord\")\n              .selectAll(\"path\")\n                .data(chord.chords)\n              .enter().append(\"path\")\n                .attr(\"d\", d3.svg.chord().radius(innerRadius))\n                .style(\"fill\", function(d) { return fill(d.target.index); })\n                .style(\"opacity\", 1);\n\n            // Returns an event handler for fading a given chord group.\n            function fade(opacity,t) {\n              return function(g, i) {\n                text_label.text (t ? lookup[i] : \"\");\n                svg.selectAll(\".chord path\")\n                    .filter(function(d) { return d.source.index != i && d.target.index != i; })\n                  .transition()\n                    .style(\"opacity\", opacity);\n              };\n            }\n        }\n  }\n\n  function attribute_pairwise_distribution (id, dim, the_map, only_expanded) {\n        var scan_from = only_expanded ? draw_me.edges : self.edges;\n        var the_matrix = [];\n        for (i = 0 ; i < dim; i+=1) {\n            the_matrix.push([]);\n            for (j = 0; j < dim; j += 1){\n                the_matrix[i].push (0);\n            }\n        }\n\n\n        _.each (scan_from,\n            function (edge) {\n                the_matrix[the_map(attribute_node_value_by_id(self.nodes[edge.source], id))][the_map(attribute_node_value_by_id(self.nodes[edge.target], id))] += 1;\n            });\n        // check if there are null values\n\n        var haz_null = the_matrix.some (function (d, i) { if (i == dim - 1) {return d.some (function (d2) {return d2 > 0;});} return d[dim-1] > 0;});\n        if (!haz_null) {\n            the_matrix.pop();\n            for (i = 0 ; i < dim - 1; i+=1) {\n                the_matrix[i].pop();\n            }\n        }\n\n        return the_matrix;\n  }\n\n  function attribute_cluster_distribution (the_cluster, attribute_id) {\n        if (attribute_id && the_cluster) {\n            return the_cluster.children.map (function (d) {return attribute_node_value_by_id (d, attribute_id);});\n        }\n        return null;\n  }\n\n  function cluster_info_string (id) {\n      var the_cluster = self.clusters[id-1],\n          attr_info = the_cluster[\"binned_attributes\"];\n\n\n\n      var str = \"<strong>\" + self.cluster_sizes[id-1] + \"</strong> nodes.\" +\n             \"<br>Mean degree <em>\" + _defaultFloatFormat(the_cluster.degrees['mean']) + \"</em>\" +\n             \"<br>Max degree <em>\" + the_cluster.degrees['max'] + \"</em>\" +\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (the_cluster.cc, _defaultFloatFormat) + \"</em>\";\n\n      if (attr_info) {\n            attr_info.forEach (function (d) { str += \"<br>\" + d[0] + \" <em>\" + d[1] + \"</em>\"});\n      }\n\n      return str;\n  }\n\n  function cluster_pop_on (d) {\n      toggle_tooltip (this, true, \"Cluster \" + d.cluster_id, cluster_info_string (d.cluster_id));\n  }\n\n  function cluster_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n  function expand_cluster_handler (d, do_update, move_out) {\n    if (d.collapsed) {\n        var new_nodes = self.cluster_sizes[d.cluster_id-1] - 1;\n\n        if (new_nodes > max_points_to_render) {\n            warning_string = \"This cluster is too large to be displayed\";\n        }\n        else {\n            var leftover = new_nodes + currently_displayed_objects - max_points_to_render;\n            if (leftover > 0) {\n              for (k = 0; k < open_cluster_queue.length && leftover > 0; k++) {\n                  var cluster = self.clusters[cluster_mapping[open_cluster_queue[k]]];\n                  leftover -= cluster.children.length - 1;\n                  collapse_cluster(cluster,true);\n              }\n              if (k || open_cluster_queue.length) {\n                  open_cluster_queue.splice (0, k);\n              }\n            }\n\n            if (leftover <= 0) {\n                expand_cluster (d, !move_out);\n            }\n        }\n\n        if (do_update) {\n            self.update(false, 0.6);\n        }\n    }\n    return \"\";\n  }\n\n  function collapse_cluster_handler (d, do_update) {\n    collapse_cluster(self.clusters[cluster_mapping[d.cluster]]);\n    if (do_update) {\n        self.update(false, 0.4);\n    }\n\n  }\n\n  function center_cluster_handler (d) {\n    d.x = self.width/2;\n    d.y = self.height/2;\n    self.update(false, 0.4);\n  }\n\n  function cluster_box_size (c) {\n      return 8*Math.sqrt (c.children.length);\n  }\n\n  self.expand_some_clusters = function(subset)  {\n    subset = subset || self.clusters;\n    subset.forEach (function (x) { expand_cluster_handler (x, false); });\n    self.update ();\n  }\n\n  self.select_some_clusters = function (condition) {\n    return self.clusters.filter (function (c, i) {\n        return _.some(c.children, (function (n) {return condition (n);}));\n    });\n  }\n\n  self.collapse_some_clusters = function(subset) {\n    subset = subset || self.clusters;\n    subset.forEach (function (x) { if (!x.collapsed) collapse_cluster (x); });\n    self.update();\n  }\n\n  self.toggle_hxb2 = function()  {\n    self.hide_hxb2 = !self.hide_hxb2;\n    self.update();\n  }\n\n  $('#reset_layout').click(function(e) {\n    default_layout(clusters, nodes);\n    self.update ();\n    e.preventDefault();// prevent the default anchor functionality\n    });\n\n  function stratify (array) {\n    if (array) {\n        var dict = {},\n            stratified = [];\n\n        array.forEach (function (d) { if (d in dict) {dict[d] += 1;} else {dict[d] = 1;}});\n        for (var uv in dict) {\n            stratified.push ([uv, dict[uv]]);\n        }\n        return stratified.sort (function (a,b) {\n              return a[0] - b[0];\n            });\n     }\n     return array;\n   }\n\n  /*------------ Event Functions ---------------*/\n  function toggle_tooltip(element, turn_on, title, tag) {\n    //if (d3.event.defaultPrevented) return;\n    if (turn_on && !element.tooltip) {\n\n      // check to see if there are any other tooltips shown\n     ($(\"[role='tooltip']\")).each (function (d) {\n        $(this).remove();\n     });\n\n      var this_box = $(element);\n      var this_data = d3.select(element).datum();\n      element.tooltip = this_box.tooltip({\n                 title: title + \"<br>\" + tag,\n                 html: true,\n                 container: 'body',\n               });\n\n      //this_data.fixed = true;\n\n      _.delay (_.bind(element.tooltip.tooltip, element.tooltip), 500, 'show');\n    } else {\n      if (turn_on == false && element.tooltip) {\n        element.tooltip.tooltip('destroy');\n        element.tooltip = undefined;\n      }\n    }\n  }\n  initial_json_load();\n  if (options) {\n    if (_.isNumber(options [\"charge\"])) {\n        self.charge_correction = options [\"charge\"];\n    }\n\n    if (\"colorizer\" in options) {\n        self.colorizer = options[\"colorizer\"];\n    }\n\n    if (\"node_shaper\" in options) {\n        self.node_shaper = options[\"node_shaper\"];\n    }\n\n    draw_attribute_labels();\n    network_layout.start ();\n\n    if (_.isArray (options [\"expand\"])) {\n        self.expand_some_clusters (_.filter (self.clusters, function (c) {console.log (c); return options[\"expand\"].indexOf (c.cluster_id) >=0;}));\n    }\n  }\n  return self;\n}\n\n\n\nvar hivtrace_cluster_graph_summary = function (graph, tag) {\n\n    var summary_table = d3.select (tag).append (\"tbody\");\n\n    var table_data = [];\n\n    if (!summary_table.empty()) {\n        _.each (graph[\"Network Summary\"], function (value, key) {\n            table_data.push ([key, value]);\n        });\n    }\n\n    var degrees = [];\n    _.each (graph [\"Degrees\"][\"Distribution\"], function (value, index) { for (k = 0; k < value; k++) {degrees.push (index+1);}});\n    degrees = datamonkey.helpers.describe_vector (degrees);\n    table_data.push (['Degrees', '']);\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n\n    degrees = datamonkey.helpers.describe_vector (graph [\"Cluster sizes\"]);\n    table_data.push (['Cluster sizes', '']);\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n\n\n    summary_table.selectAll (\"tr\").data (table_data).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").html (function (d) {return d});\n}\n\ndatamonkey.hivtrace.cluster_network_graph = hivtrace_cluster_network_graph;\ndatamonkey.hivtrace.graph_summary = hivtrace_cluster_graph_summary;\n","\nfunction hivtrace_render_scatterplot(points, w, h, id, labels) {\n\n    var margin = {top: 10, right: 10, bottom: 70, left: 70},\n                width = w - margin.left - margin.right,\n                height = h - margin.top - margin.bottom;\n\n    var x = d3.scale.linear()\n            .domain(d3.extent (points, function (p) {return p.x;}))\n            .range([0, width]);\n\n    var y = d3.scale.linear()\n            .domain (d3.extent (points, function (p) {return p.y;}))\n            .range  ([height,0]);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\").tickFormat (_defaultFloatFormat);\n\n    var yAxis = d3.svg.axis()\n        .scale(y)\n        .orient(\"left\").tickFormat (_defaultFloatFormat);\n\n\n\n    var histogram_svg = d3.select(id).selectAll(\"svg\");\n\n    if (!histogram_svg.empty()) {\n        histogram_svg.remove();\n    }\n\n    histogram_svg = d3.select(id).append (\"svg\").attr (\"width\", w).attr (\"height\", h).append (\"g\").attr (\"transform\", \"translate(\"  +  margin.left + \",\" + margin.top + \")\");\n\n    var points = histogram_svg.selectAll (\"circle\").data (points);\n    points.enter().append (\"circle\");\n\n    points.attr (\"cx\", function (d) {return x(d.x);}).attr (\"cy\", function (d) {return y (d.y);}).attr (\"r\", 3).classed (\"node scatter\", true);\n\n    points.each (function (d) {\n        if (\"title\" in d) {\n            d3.select (this).append (\"title\").text (d.title);\n        }\n    });\n\n     var x_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(xAxis);\n\n\n    x_axis.selectAll (\"text\").attr (\"transform\", \"rotate(-45)\").attr(\"dx\",\"-.5em\").attr(\"dy\",\".25em\").style (\"text-anchor\", \"end\");\n    x_axis.append (\"text\").text (labels.x).attr (\"transform\", \"translate(\" + width + \",0)\").attr (\"dy\", \"-1em\").attr (\"text-anchor\", \"end\");\n\n     var y_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"y axis\")\n        .attr(\"transform\", \"translate(0,\" + 0 + \")\")\n        .call(yAxis);\n\n   y_axis.selectAll (\"text\").attr (\"transform\", \"rotate(-45)\").attr(\"dx\",\"-.5em\").attr(\"dy\",\".25em\").style (\"text-anchor\", \"end\");\n   y_axis.append (\"text\").text (labels.y).attr (\"transform\", \"rotate(-90)\").attr (\"dy\", \"1em\").attr (\"text-anchor\", \"end\");\n\n}\n\ndatamonkey.hivtrace.scatterplot = hivtrace_render_scatterplot;\n"],"sourceRoot":"/source/"}